<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my Qzone</title>
  
  
  <link href="https://blog.yuanchenxi95.com/atom.xml" rel="self"/>
  
  <link href="https://blog.yuanchenxi95.com/"/>
  <updated>2025-03-19T04:38:52.869Z</updated>
  <id>https://blog.yuanchenxi95.com/</id>
  
  <author>
    <name>Chenxi Yuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小米集团2024年报</title>
    <link href="https://blog.yuanchenxi95.com/2025/03/18/%E5%B0%8F%E7%B1%B3%E9%9B%86%E5%9B%A22024%E5%B9%B4%E6%8A%A5/"/>
    <id>https://blog.yuanchenxi95.com/2025/03/18/%E5%B0%8F%E7%B1%B3%E9%9B%86%E5%9B%A22024%E5%B9%B4%E6%8A%A5/</id>
    <published>2025-03-19T03:00:46.000Z</published>
    <updated>2025-03-19T04:38:52.869Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ir.mi.com/system/files-encrypted/nasdaq_kms/assets/2025/03/18/5-39-22/%E4%B8%AD%E6%96%87%E5%85%AC%E5%91%8A.pdf">小米2024年财报</a></p><h2 id="小米集团产品分类"><a href="#小米集团产品分类" class="headerlink" title="小米集团产品分类"></a>小米集团产品分类</h2><ul><li>手机</li><li>IoT</li><li>家电（空调，冰箱，洗衣机）</li><li>互联网服务</li><li>电动汽车</li></ul><h2 id="整体表现"><a href="#整体表现" class="headerlink" title="整体表现"></a>整体表现</h2><table><thead><tr><th align="left">指标</th><th align="left">数值（人民币）</th><th align="left">同比增长率</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">集团总收入</td><td align="left">3,659亿</td><td align="left">35.0%</td><td align="left">创历史新高</td></tr><tr><td align="left">手机×AIoT分部收入</td><td align="left">3,332亿</td><td align="left">22.9%</td><td align="left"></td></tr><tr><td align="left">智能电动汽车等创新业务分部收入</td><td align="left">328亿</td><td align="left">-</td><td align="left"></td></tr><tr><td align="left">集团经调整净利润</td><td align="left">272亿</td><td align="left">41.3%</td><td align="left">创历史新高，含创新业务亏损62亿元</td></tr><tr><td align="left">智能电动汽车等创新业务经调整净亏损</td><td align="left">62亿</td><td align="left">-</td><td align="left">于集团经调整净利润内包含此项亏损。</td></tr></tbody></table><h3 id="研发"><a href="#研发" class="headerlink" title="研发"></a>研发</h3><p>研发支出241亿人民币，研发人员21190人，占员工总数48.5%。</p><h3 id="评："><a href="#评：" class="headerlink" title="评："></a>评：</h3><ol><li>对比其他<a href="#%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E5%91%98%E5%B7%A5%E6%95%B0%E6%8D%AE">互联网公司</a>，小米的研发人员和员工总数相对较低。对比小米业务线，未来研发人员或许会大幅增加。</li></ol><h2 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h2><ul><li>2024年，小米在全球56个国家和地区的智能手机出货量排名前三，在69个国家和地区的智能手机出货量排名前五。<br>非洲、东南亚和中东的智能手机市场份额均实现显著增长。</li><li>在中国大陆地区，2024年高端智能手机（零售价人民币3,000元及以上）出货量在整体智能手机出货量中的占比达到23.3%，同比增长3.0个百分点。</li><li>据Canalys数据，2024年小米在全球智能手机出货量中排名第三，市场份额为13.8%，同比增长1.0个百分点。</li><li>根据Canalys数据，2024年第四季度，小米在中国大陆的市场份额同比增长3.0个百分点至15.8%。</li></ul><h3 id="评：-1"><a href="#评：-1" class="headerlink" title="评："></a>评：</h3><ol><li>小米手机的大陆销量仅占总出货量的23.3%。即便未来中国持续处于通缩状态，小米手机的营收依旧可以依靠全球业务支撑。</li><li>按区域划分，手机销售量和互联网服务中的活跃用户相吻合</li></ol><h2 id="IoT"><a href="#IoT" class="headerlink" title="IoT"></a>IoT</h2><ul><li>AIoT平台已连接的IoT设备数（不包括智能手机、平板及笔记本电脑）增长至904.6百万，同比增长22.3%。</li><li>拥有五件及以上连接至我们AIoT平台的设备（不包括智能手机、平板及笔记本电脑）用户数达到18.3百万，同比增长26.1%。 </li><li>2024年12月，米家APP的月活跃用户数同比增长17.5%至100.8百万，小爱同学的月活跃用户数同比增长12.0%至137.1百万。 </li><li>平板业务在2024年延续高增长态势。根据 Canalys 数据，小米的全球平板产品出货量同比增长 73.1%，是全球前五厂商中<br>增速最快的，全球出货量排名前五，中国大陆排名前三。 </li><li>小米在可穿戴产品领域保持领先优势。根据 Canalys 数据，2024年，小米的可穿戴腕带设备在全球和中国大陆地区均排名第二，TWS<br>耳机在中国大陆地区出货量排名第一。 </li><li>小米耳机功能更新：降噪，AI功能（录音，翻译，同传）。</li></ul><h3 id="评：-2"><a href="#评：-2" class="headerlink" title="评："></a>评：</h3><ol><li>结合金山云的业务增长和万卡集群的建设：<ol><li><a href="https://www.ksyun.com/ns/news/detail/302">两年100亿次唤醒 金山云为小爱同学提供顶级技术支持</a></li><li><a href="https://finance.sina.com.cn/stock/relnews/us/2024-12-27/doc-ineaxeft7422300.shtml">GPU万卡集群搭建中，金山云股价涨超14%，小米及金山生态需求即将放量</a></li></ol></li></ol><h2 id="家电（空调，冰箱，洗衣机）"><a href="#家电（空调，冰箱，洗衣机）" class="headerlink" title="家电（空调，冰箱，洗衣机）"></a>家电（空调，冰箱，洗衣机）</h2><table><thead><tr><th>产品</th><th>出货量</th><th>同比增速</th><th>备註</th></tr></thead><tbody><tr><td>空调</td><td>超过 680 万台</td><td>超过 50%</td><td>创历史新高</td></tr><tr><td>冰箱</td><td>超过 270 万台</td><td>超过 30%</td><td>创历史新高</td></tr><tr><td>洗衣机</td><td>超过 190 万台</td><td>超过 45%</td><td>创历史新高</td></tr></tbody></table><ul><li>米家中央空调Pro搭载双缸压缩机，并且支持超一级能效。智能化方面，米家中央空调Pro搭载米家灵云智控引擎，控温更稳更准，提高舒适度。</li><li>空调、智能电视、冰箱、洗衣机、热水器、智能门锁6大核心品类，完成送拆装一站式服务升级，覆盖全国<b>2,898个区县</b>。</li></ul><h3 id="评：-3"><a href="#评：-3" class="headerlink" title="评："></a>评：</h3><ol><li>结合2021小米之家的门店覆盖率：<ol><li>小米集团合伙人，中国区、国际部总裁，Redmi品牌总经理卢伟冰在发布会现场宣布，截至2021年10月底，小米之家门店数量将正式突破1万家，<br>同时县城市场的覆盖率超过了80%，这是小米新零售发展史上里程碑式的新突破。<a href="https://www.stcn.com/article/detail/462792.html">Source</a></li></ol></li><li>冲这个趋势，估计25年就能超越格力，美的，海尔</li></ol><h2 id="互联网服务"><a href="#互联网服务" class="headerlink" title="互联网服务"></a>互联网服务</h2><h3 id="营收"><a href="#营收" class="headerlink" title="营收"></a>营收</h3><ul><li>互联网服务收入达到人民币 341 亿元，较 2023 年的人民币 301 亿元同比增长 13.3%</li><li>互联网服务毛利率为 76.6%，较 2023 年的 74.2%同比提升 2.5 个百分点</li><li>广告业务营收247亿元</li></ul><h3 id="分区域数据"><a href="#分区域数据" class="headerlink" title="分区域数据"></a>分区域数据</h3><ul><li>2024年，境外互联网服务收入同比增长 30.0% 至人民币 110 亿元，占整体互联网服务收入的 32.2%，同比提升 4.1 个百分点。</li><li>全球月活跃用户数达到702.3百万，同比增长9.5%。<ul><li>其中，中国大陆月活跃用户数达到172.9百万，同比增长11.1%。</li><li>智能电视全球月活跃用户数达到70.7百万，同比增长7.1%。</li></ul></li></ul><h3 id="评：-4"><a href="#评：-4" class="headerlink" title="评："></a>评：</h3><ol><li>营收来源主要为广告业务。对比苹果2025Q1 service revenue 26b美元，苹果的active devices数量为2.35b。</li><li><b>小米的海外活跃用户占比高达75%</b></li></ol><h2 id="电动汽车"><a href="#电动汽车" class="headerlink" title="电动汽车"></a>电动汽车</h2><ul><li>电动汽车收入328亿，电车毛利率18.5%。净亏损62亿元。</li><li>布局销售服务网络，中国大陆58个城区，200家汽车销售门店。</li><li>2025年预期交付35万台。</li></ul><h3 id="评：-5"><a href="#评：-5" class="headerlink" title="评："></a>评：</h3><ol><li>产能爬坡，工厂建设，销售网络建设<ol><li><a href="https://stcn.com/article/detail/1366166.html">实探小米汽车二期工厂：工人全天赶工，今年底能封顶</a> 2024-10-24</li><li><a href="https://www.wuhan.gov.cn/sy/whyw/202411/t20241128_2490688.shtml">小米首座智能家电工厂落户武汉，一期项目聚焦空调品类</a> 2024-11-28</li></ol></li></ol><h2 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h2><h3 id="互联网公司员工数据"><a href="#互联网公司员工数据" class="headerlink" title="互联网公司员工数据"></a>互联网公司员工数据</h3><table><thead><tr><th>公司名称</th><th>员工数量（估计）</th><th>研发支出（人民币 亿元）</th><th>研发支出（美元 亿元）</th><th>收入（人民币 亿元）</th><th>收入（美元 亿元）</th><th>研发支出占收入比例</th></tr></thead><tbody><tr><td>阿里巴巴集团</td><td>235,216</td><td>567.44</td><td>82.63</td><td>2082</td><td>303.16</td><td>27.26%</td></tr><tr><td>腾讯控股</td><td>105,417</td><td>640.78</td><td>93.39</td><td>5552</td><td>808.99</td><td>11.54%</td></tr><tr><td>百度公司</td><td>~150,000</td><td>242</td><td>34.1</td><td>1346</td><td>189.6</td><td>18.00%</td></tr><tr><td>美团</td><td>114,731</td><td>212.01</td><td>29</td><td>2767</td><td>383</td><td>7.66%</td></tr><tr><td>字节跳动</td><td>&gt;150,000</td><td>未知</td><td>未知</td><td>未知</td><td>~1460</td><td><br/>未知</td></tr></tbody></table><p>数据来源：Gemini deep research</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ir.mi.com/system/files-encrypted/nasdaq_kms/assets/2025/03/18/5-39-22/%E4%B8%AD%E6%96%87%E5%85%AC%E5%91%8A.pdf&quot;&gt;小米2024年财</summary>
      
    
    
    
    
    <category term="Earnings" scheme="https://blog.yuanchenxi95.com/tags/Earnings/"/>
    
    <category term="Xiaomi" scheme="https://blog.yuanchenxi95.com/tags/Xiaomi/"/>
    
    <category term="xiacy" scheme="https://blog.yuanchenxi95.com/tags/xiacy/"/>
    
  </entry>
  
  <entry>
    <title>tech-blog-index</title>
    <link href="https://blog.yuanchenxi95.com/2025/02/13/tech-blog-index/"/>
    <id>https://blog.yuanchenxi95.com/2025/02/13/tech-blog-index/</id>
    <published>2025-02-14T04:37:28.000Z</published>
    <updated>2025-02-14T04:49:19.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预测技术在美团弹性伸缩场景的探索与应用"><a href="#预测技术在美团弹性伸缩场景的探索与应用" class="headerlink" title="预测技术在美团弹性伸缩场景的探索与应用"></a>预测技术在美团弹性伸缩场景的探索与应用</h1><ul><li>title: 预测技术在美团弹性伸缩场景的探索与应用</li><li>link: <a href="https://mp.weixin.qq.com/s/7dwa3S2ziUed59O_idJq_A">https://mp.weixin.qq.com/s/7dwa3S2ziUed59O_idJq_A</a></li><li>tags: [‘美团’, ‘auto scaling’]</li><li>date: 2025-02-13</li></ul><h1 id="从-ClickHouse-到-Apache-Doris：在网易云音乐日增万亿日志数据场景下的落地"><a href="#从-ClickHouse-到-Apache-Doris：在网易云音乐日增万亿日志数据场景下的落地" class="headerlink" title="从 ClickHouse 到 Apache Doris：在网易云音乐日增万亿日志数据场景下的落地"></a>从 ClickHouse 到 Apache Doris：在网易云音乐日增万亿日志数据场景下的落地</h1><ul><li>title: 从 ClickHouse 到 Apache Doris：在网易云音乐日增万亿日志数据场景下的落地</li><li>link: <a href="https://mp.weixin.qq.com/s/iY-h-tkklSPSX7gxle9lzA">https://mp.weixin.qq.com/s/iY-h-tkklSPSX7gxle9lzA</a></li><li>tags: [‘网易’, ‘Apache Doris’, ‘Big Data’, ‘High throughput logging’]</li><li>date: 2025-02-13</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;预测技术在美团弹性伸缩场景的探索与应用&quot;&gt;&lt;a href=&quot;#预测技术在美团弹性伸缩场景的探索与应用&quot; class=&quot;headerlink&quot; title=&quot;预测技术在美团弹性伸缩场景的探索与应用&quot;&gt;&lt;/a&gt;预测技术在美团弹性伸缩场景的探索与应用&lt;/h1&gt;&lt;ul&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Netflix财报2024Q2总结</title>
    <link href="https://blog.yuanchenxi95.com/2024/07/19/Netflix%E8%B4%A2%E6%8A%A52024Q2%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.yuanchenxi95.com/2024/07/19/Netflix%E8%B4%A2%E6%8A%A52024Q2%E6%80%BB%E7%BB%93/</id>
    <published>2024-07-20T03:06:41.000Z</published>
    <updated>2025-02-14T04:48:41.017Z</updated>
    
    <content type="html"><![CDATA[<p>Netflix 2024Q2 财报：<br><a href="https://s22.q4cdn.com/959853165/files/doc_financials/2024/q2/FINAL-Q2-24-Shareholder-Letter.pdf">https://s22.q4cdn.com/959853165/files/doc_financials/2024/q2/FINAL-Q2-24-Shareholder-Letter.pdf</a></p><h2 id="Financial-Data"><a href="#Financial-Data" class="headerlink" title="Financial Data"></a>Financial Data</h2><table><thead><tr><th align="left">Metric</th><th align="left">Q2’23</th><th align="left">Q3’23</th><th align="left">Q4’23</th><th align="left">Q1’24</th><th align="left">Q2’24</th><th align="left">Q3’24 Forecast</th></tr></thead><tbody><tr><td align="left"><strong>Revenue</strong></td><td align="left">$8,187</td><td align="left">$8,542</td><td align="left">$8,833</td><td align="left">$9,370</td><td align="left">$9,559</td><td align="left">$9,727</td></tr><tr><td align="left"><em><strong>Y&#x2F;Y % Growth</strong></em></td><td align="left">2.7%</td><td align="left">7.8%</td><td align="left">12.5%</td><td align="left">14.8%</td><td align="left">16.8%</td><td align="left">13.9%</td></tr><tr><td align="left"><strong>Operating Income</strong></td><td align="left">$1,827</td><td align="left">$1,916</td><td align="left">$1,496</td><td align="left">$2,633</td><td align="left">$2,603</td><td align="left">$2,730</td></tr><tr><td align="left"><em><strong>Operating Margin</strong></em></td><td align="left">22.3%</td><td align="left">22.4%</td><td align="left">16.9%</td><td align="left">28.1%</td><td align="left">27.2%</td><td align="left">28.1%</td></tr><tr><td align="left"><strong>Net Income</strong></td><td align="left">$1,488</td><td align="left">$1,677</td><td align="left">$938</td><td align="left">$2,332</td><td align="left">$2,147</td><td align="left">$2,237</td></tr><tr><td align="left"><strong>Diluted EPS</strong></td><td align="left">$3.29</td><td align="left">$3.73</td><td align="left">$2.11</td><td align="left">$5.28</td><td align="left">$4.88</td><td align="left">$5.10</td></tr><tr><td align="left"><strong>Global Streaming Paid Memberships</strong></td><td align="left">238.39M</td><td align="left">247.15M</td><td align="left">260.28M</td><td align="left">269.60M</td><td align="left">277.65M</td><td align="left"></td></tr><tr><td align="left"><em><strong>Y&#x2F;Y % Growth</strong></em></td><td align="left">8.0%</td><td align="left">10.8%</td><td align="left">12.8%</td><td align="left">16.0%</td><td align="left">16.5%</td><td align="left"></td></tr><tr><td align="left"><strong>Global Streaming Paid Net Additions</strong></td><td align="left">5.89M</td><td align="left">8.76M</td><td align="left">13.12M</td><td align="left">9.33M</td><td align="left">8.05M</td><td align="left"></td></tr><tr><td align="left"><strong>Net cash provided by operating activities</strong></td><td align="left">$1,440</td><td align="left">$1,992</td><td align="left">$1,663</td><td align="left">$2,213</td><td align="left">$1,291</td><td align="left"></td></tr><tr><td align="left"><strong>Free Cash Flow</strong></td><td align="left">$1,339</td><td align="left">$1,888</td><td align="left">$1,581</td><td align="left">$2,137</td><td align="left">$1,213</td><td align="left"></td></tr><tr><td align="left"><strong>Shares (FD)</strong></td><td align="left">451.6M</td><td align="left">450.0M</td><td align="left">444.3M</td><td align="left">441.7M</td><td align="left">439.7M</td><td align="left"></td></tr></tbody></table><p>Global Streaming Paid Net Additions增长了8m，Q2股票数环比减少2.6m（由于回购）。</p><h2 id="市场排名"><a href="#市场排名" class="headerlink" title="市场排名"></a>市场排名</h2><p>根据Nielsen’s The Gauge的Share of US TV Screen Time调查，Youtube占9.9%，Netflix占8.4%排在第二，第三的Amazon Prime Video占3.1%。</p><p>streaming, pay TV, film, games, branded advertising总市场份额大概600b美元，Netflix大概占据6%的市场份额。</p><p>评：Netflix并没有提及短视频平台tiktok对streaming业务的影响</p><h2 id="产品种类"><a href="#产品种类" class="headerlink" title="产品种类"></a>产品种类</h2><h3 id="剧和电影"><a href="#剧和电影" class="headerlink" title="剧和电影"></a>剧和电影</h3><table><thead><tr><th align="left">Title</th><th align="left">Views (Millions)</th></tr></thead><tbody><tr><td align="left"><em>Bridgerton</em> Season 3</td><td align="left">98.5</td></tr><tr><td align="left"><em>Queen Charlotte</em></td><td align="left">Included in <em>Bridgerton</em> Universe (172M)</td></tr><tr><td align="left"><em>Under Paris</em></td><td align="left">90.9</td></tr><tr><td align="left"><em>Atlas</em></td><td align="left">79.3</td></tr><tr><td align="left"><em>Baby Reindeer</em></td><td align="left">88.4</td></tr><tr><td align="left"><em>Heeramandi: The Diamond Bazaar</em></td><td align="left">15.0</td></tr><tr><td align="left"><em>Amar Singh Chamkila</em></td><td align="left">8.3</td></tr><tr><td align="left"><em>The Roast of Tom Brady</em></td><td align="left">22.6</td></tr><tr><td align="left"><em>The Asunta Case</em></td><td align="left">31.3</td></tr><tr><td align="left"><em>Crooks</em></td><td align="left">15.7</td></tr><tr><td align="left"><em>Queen of Tears</em></td><td align="left">29.3</td></tr><tr><td align="left"><em>Hit Man</em></td><td align="left">33.2</td></tr><tr><td align="left"><em>City Hunter</em></td><td align="left">16.5</td></tr></tbody></table><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>Netflix特别提及了Grand Theft Auto的火爆</p><ul><li><strong>Netflix Stories:</strong> This is a collection of interactive fiction games based on popular Netflix series and films:<ul><li><strong>Love is Blind</strong></li><li><strong>Virgin River</strong></li><li><strong>Perfect Match</strong></li><li><strong>Emily in Paris</strong> (upcoming)</li><li><strong>Selling Sunset</strong> (upcoming)</li></ul></li><li>**Squid Game (Upcoming Multiplayer Game):</li></ul><p>Netflix并没有给出具体的各个游戏玩家数据</p><h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><ul><li>提到了自家的推荐系统：“会持续提升推荐系统，尽管目前已经是行业领先”。</li><li>发布了新的TV homepage设计，更新了一些具体的显示和UI设置。<br>评：没有公布具体的ab测试数据</li><li>重新设计了My Netflix</li></ul><h3 id="Partnerships"><a href="#Partnerships" class="headerlink" title="Partnerships"></a>Partnerships</h3><ul><li>和厂家合作确保Netflix “easy to find and use”</li><li>没有和Disney+还有Max打包销售，Netflix认为自己在市场上有领先地位</li></ul><h2 id="广告业务"><a href="#广告业务" class="headerlink" title="广告业务"></a>广告业务</h2><ul><li>Netflix着重讲述了广告业务的发展，目前45%的新注册用户来自广告tier。Q2，广告tier的用户数增长34%。</li><li>提升对广告商的服务<ul><li>在UK，和Barb合作，使广告客户能更好的”plan campaigns”和”understand their audiences on Netflix”</li><li>“pause”和”keep watching”广告beta版。客户包括Expedia, Coca-Cola, Ford, L’Oréal and McDonald’s</li><li>Netflix在自建广告基建，会在2024年晚些时候在加拿大测试，2025年会在其他地区扩大测试规模</li><li>Netflix也在测试集成Trade Desk, Google DV 360, and Magnite.</li></ul></li><li>2025会增加广告付费用户的规模。而且广告收入也称为很重要的一部分。</li><li>建立广告系统需要时间，Netflix并不期待广告收入会成为主要收入来源。</li><li>Netflix担忧广告业务的增速太快，以至于变现能力不足以应付需求。</li></ul><p>Here is a summary of the cash flow and capital structure information found in the sources, presented in Chinese:</p><h2 id="Netflix-第二季度现金流和资本结构概述"><a href="#Netflix-第二季度现金流和资本结构概述" class="headerlink" title="Netflix 第二季度现金流和资本结构概述"></a>Netflix 第二季度现金流和资本结构概述</h2><ul><li><p><strong>现金流：</strong> Netflix 报告称，2024 年第二季度运营活动产生的净现金为 13 亿美元，而 2023 年同期为 14 亿美元。2024 年第二季度自由<br>现金流（FCF）总计 12 亿美元，而去年同期为 13 亿美元。该公司预计，假设汇率没有重大波动，2024 年全年自由现金流约为 60 亿美元。</p></li><li><p><strong>资本结构：</strong> 截至 2024 年第二季度末，Netflix 的总债务为 140 亿美元，现金、现金等价物和短期投资总额为 67 亿美元。 公司在未来 12<br>个月内有 18 亿美元的债务到期，计划进行再融资。 此外，Netflix 在 2024 年第二季度回购了 260 万股股票，耗资 16 亿美元，现有股票回购授权<br>还有 50 亿美元的额度。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Netflix 2024Q2 财报：&lt;br&gt;&lt;a href=&quot;https://s22.q4cdn.com/959853165/files/doc_financials/2024/q2/FINAL-Q2-24-Shareholder-Letter.pdf&quot;&gt;https://s</summary>
      
    
    
    
    
    <category term="Earnings" scheme="https://blog.yuanchenxi95.com/tags/Earnings/"/>
    
    <category term="Netflix" scheme="https://blog.yuanchenxi95.com/tags/Netflix/"/>
    
  </entry>
  
  <entry>
    <title>HTTP新method: Query</title>
    <link href="https://blog.yuanchenxi95.com/2022/01/31/HTTP%E6%96%B0method-Query/"/>
    <id>https://blog.yuanchenxi95.com/2022/01/31/HTTP%E6%96%B0method-Query/</id>
    <published>2022-02-01T07:50:36.000Z</published>
    <updated>2025-02-14T04:48:41.017Z</updated>
    
    <content type="html"><![CDATA[<p>About: IETF最近的一个关于HTTP新method的proposal</p><h2 id="GET为什么不应该有body"><a href="#GET为什么不应该有body" class="headerlink" title="GET为什么不应该有body"></a>GET为什么不应该有body</h2><p>根据 <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1">HTTP Spec</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A payload within a GET request message has no defined semantics</span><br></pre></td></tr></table></figure><p>GET request的payload是没有定义的，可以理解为<a href="https://evertpot.com/get-request-bodies/">C语言中的undefined behavior</a>，文章中还提到了，<br>GET bodies从不被 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch</a> 支持，变成了虽然支持，但是会警告开发者尽量不要用。</p><p>因为是 undefined behavior，所以 GET 请求中的 Body，理论上来讲可以被随意处理，像HackerNews<br>上这个 <a href="https://news.ycombinator.com/item?id=30155696">Comment</a> 所说的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line">GET with a body is iffy. If you owned the entire stack it might be doable. </span><br><span class="line">...</span><br><span class="line">Proxies or firewalls can just drop the message and be completely HTTP compliant.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>GET的body是具有不确定性的，Load Balancer理论上是可以直接丢掉Body内容的。</p><h2 id="新Method-“QUERY”有什么好处"><a href="#新Method-“QUERY”有什么好处" class="headerlink" title="新Method “QUERY”有什么好处"></a>新Method “QUERY”有什么好处</h2><h3 id="Safe-and-Idempotent"><a href="#Safe-and-Idempotent" class="headerlink" title="Safe and Idempotent"></a>Safe and Idempotent</h3><p><a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-safe-method-w-body-02#section-2">Proposal Section 2</a><br>里提到的最重要的好处是safe和Idempotent。</p><p>对比POST，QUERY不应改变服务器上的内容，也就是只读请求，而且QUERY同样也应该是幂等的，<br>“以相同的请求调用这个接口一次和调用这个接口多次，对系统产生的影响是相同的”。</p><h3 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h3><p><a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-safe-method-w-body-02#section-2.1">Proposal Section 2.1</a> 所提到的，QUERY支持<a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cache-19#section-4">HTTP caching的标准</a>。</p><p>综合来看，QUERY相当于是一个支持了Body的GET。对比传统通过POST来传Body实现复杂查询，有一些优势。</p><h2 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h2><p>HTTP定义的这些方法在当前真的符合各个不同应用的需求吗，HTTP是否应该在它这一层去定义这些方法，<br>是否应该由一层只处理单向或双向的消息通讯协议， 其余的逻辑，由更上层的协议去做。<br>像GraphQL在HTTP POST之上定义自己的Query和Mutation逻辑。</p><h1 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h1><ol><li><a href="https://evertpot.com/get-request-bodies/">Request bodies in GET requests</a></li><li><a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-safe-method-w-body-02">The HTTP QUERY Method</a></li><li><a href="https://news.ycombinator.com/item?id=30129631">Hackernews Thread: Request bodies in GET requests</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;About: IETF最近的一个关于HTTP新method的proposal&lt;/p&gt;
&lt;h2 id=&quot;GET为什么不应该有body&quot;&gt;&lt;a href=&quot;#GET为什么不应该有body&quot; class=&quot;headerlink&quot; title=&quot;GET为什么不应该有body&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="HTTP" scheme="https://blog.yuanchenxi95.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Coroutine LockFreeTaskQueue 源码注释</title>
    <link href="https://blog.yuanchenxi95.com/2021/11/09/Kotlin-Coroutine-LockFreeTaskQueue-%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A/"/>
    <id>https://blog.yuanchenxi95.com/2021/11/09/Kotlin-Coroutine-LockFreeTaskQueue-%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A/</id>
    <published>2021-11-10T04:03:21.000Z</published>
    <updated>2025-02-14T04:48:41.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lock-Free-Task-Queue"><a href="#Lock-Free-Task-Queue" class="headerlink" title="Lock Free Task Queue"></a><a href="https://github.com/Kotlin/kotlinx.coroutines/blob/5e870c11311b3bfd58f0557c651f1d877e9e5827/kotlinx-coroutines-core/common/src/internal/LockFreeTaskQueue.kt">Lock Free Task Queue</a></h2><p>对 <a href="https://github.com/Kotlin/kotlinx.coroutines">Kotlin Coroutine</a> 的Lock Free Task Queue的注释</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="meta-string">&quot;PrivatePropertyName&quot;</span>, <span class="meta-string">&quot;MemberVisibilityCanBePrivate&quot;</span>)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> INITIAL_CAPACITY = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为LockFreeTaskQueue用一个Atomic Long存储queue的state，来确保每次更新state都是原子操作</span></span><br><span class="line">    <span class="comment">// - head: 30 bit，用来记录circular queue的head index</span></span><br><span class="line">    <span class="comment">// - tail: 30 bit，用来记录circular queue的tail index</span></span><br><span class="line">    <span class="comment">// - frozen: 1 bit，indicate当前的queue是否被冻结</span></span><br><span class="line">    <span class="comment">// - closed: 1 bit, indicate当前的queue是否被close</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> CAPACITY_BITS = <span class="number">30</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> MAX_CAPACITY_MASK = (<span class="number">1</span> shl CAPACITY_BITS) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> HEAD_SHIFT = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Head Mask: 用来从Long state里获取head的Int值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> HEAD_MASK = MAX_CAPACITY_MASK.toLong() shl HEAD_SHIFT</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> TAIL_SHIFT = HEAD_SHIFT + CAPACITY_BITS</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Tail Mask: 用来从Long state里获取tail的Int值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> TAIL_MASK = MAX_CAPACITY_MASK.toLong() shl TAIL_SHIFT</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> FROZEN_SHIFT = TAIL_SHIFT + CAPACITY_BITS</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Frozen Mask: 用来从Long state里获取frozen的flag </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> FROZEN_MASK = <span class="number">1L</span> shl FROZEN_SHIFT</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> CLOSED_SHIFT = FROZEN_SHIFT + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Closed Mask: 用来从Long state里获取closed的flag</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> CLOSED_MASK = <span class="number">1L</span> shl CLOSED_SHIFT</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> MIN_ADD_SPIN_CAPACITY = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> REMOVE_FROZEN = Symbol(<span class="string">&quot;REMOVE_FROZEN&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add to queue的enum状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成功Add to the queue</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> ADD_SUCCESS = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 失败：queue已经为frozen状态</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> ADD_FROZEN = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 失败：queue已经被close</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> ADD_CLOSED = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">wo</span><span class="params">(other: <span class="type">Long</span>)</span></span> = <span class="keyword">this</span> and other.inv()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (this wo HEAD_MASK): 抹除Long state里head的值</span></span><br><span class="line">    <span class="comment">// (newHead.toLong() shl HEAD_SHIFT): 获取一个新的Long，并写入新的head值</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">updateHead</span><span class="params">(newHead: <span class="type">Int</span>)</span></span> = (<span class="keyword">this</span> wo HEAD_MASK) or (newHead.toLong() shl HEAD_SHIFT)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (this wo TAIL_MASK): 抹除Long state里tail的值</span></span><br><span class="line">    <span class="comment">// (newHead.toLong() shl HEAD_SHIFT): 获取一个新的Long，并写入新的tail值</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">updateTail</span><span class="params">(newTail: <span class="type">Int</span>)</span></span> = (<span class="keyword">this</span> wo TAIL_MASK) or (newTail.toLong() shl TAIL_SHIFT)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="built_in">Long</span>.<span class="title">withState</span><span class="params">(block: (<span class="type">head</span>: <span class="type">Int</span>, <span class="type">tail</span>: <span class="type">Int</span>) -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="comment">// 从Long state读出head值，并转化为Int</span></span><br><span class="line">        <span class="keyword">val</span> head = ((<span class="keyword">this</span> and HEAD_MASK) shr HEAD_SHIFT).toInt()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从Long state读出tail值，并转化为Int</span></span><br><span class="line">        <span class="keyword">val</span> tail = ((<span class="keyword">this</span> and TAIL_MASK) shr TAIL_SHIFT).toInt()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> block(head, tail)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取state里的失败原因，如果是Close返回ADD_CLOSED状态，否则返回ADD_FROZEN状态</span></span><br><span class="line">    <span class="comment">// FROZEN | CLOSED</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">addFailReason</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span> (<span class="keyword">this</span> and CLOSED_MASK != <span class="number">0L</span>) ADD_CLOSED <span class="keyword">else</span> ADD_FROZEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Internal变量"><a href="#Internal变量" class="headerlink" title="Internal变量"></a>Internal变量</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> Core&lt;E&gt; = LockFreeTaskQueueCore&lt;E&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeTaskQueueCore</span>&lt;<span class="type">E : Any</span>&gt;</span>(</span><br><span class="line">    <span class="comment">// Queue最大存储的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Indicate这个queue是否只有一个consumer，这个field非常重要</span></span><br><span class="line">    <span class="comment">// note 2 翻译：</span></span><br><span class="line">    <span class="comment">// 当这个queue有多个consumer的时候，这个queue并不是Lock Free</span></span><br><span class="line">    <span class="comment">// consumer spins直到producer完成它的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> singleConsumer: <span class="built_in">Boolean</span> <span class="comment">// true when there is only a single consumer (slightly faster)</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// Mask: 用来获取queue的实际head index和tail index</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mask = capacity - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在queue扩容时，会将新生成的queue存储在这个Atomic Ref里边</span></span><br><span class="line">    <span class="comment">// 如果在扩容期间，有别的thread对当前的queue进行操作，在操作完成时，会检查当前的queue的next是否为空</span></span><br><span class="line">    <span class="comment">// 如果是null，证明此时没有扩容，写入的atomic Long state成功，queue里的item操作也成功</span></span><br><span class="line">    <span class="comment">// 如果不为null，需要将状态更新到新生成的queue中，也就是next ref的queue，</span></span><br><span class="line">    <span class="comment">// 更新完成后，需要再次检查next的next是否为空，如果不为空，则说明queue再次扩容，</span></span><br><span class="line">    <span class="comment">// 需要重新进行更新，直到更新完成后的next为null。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _next = atomic&lt;Core&lt;E&gt;?&gt;(<span class="literal">null</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Atomic Long state，用来记录queue的状态，包括：head index，tail index，是否frozen，是否closed</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _state = atomic(<span class="number">0L</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Circular Queue array，生成一个长度为capacity的array，每个item都是一个atomic ref到null</span></span><br><span class="line">    <span class="comment">// 这个queue里边存储的是需要执行的任务，consumer会从queue的head读任务出来，producer会将任务加到tail的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> array = atomicArrayOfNulls&lt;Any?&gt;(capacity)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...省略代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态方法"><a href="#状态方法" class="headerlink" title="状态方法"></a>状态方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当head index == tail index的时候，queue为空</span></span><br><span class="line"><span class="comment">// Note: it is not atomic w.r.t. remove operation (remove can transiently fail when isEmpty is false)</span></span><br><span class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = _state.value.withState &#123; head, tail -&gt; head == tail &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tail index - head index，然后mask by MAX_CAPACITY_MASK为当前queue的size</span></span><br><span class="line"><span class="keyword">val</span> size: <span class="built_in">Int</span> <span class="keyword">get</span>() = _state.value.withState &#123; head, tail -&gt; (tail - head) and MAX_CAPACITY_MASK &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前queue是否未关闭状态</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    _state.update &#123; state -&gt;</span><br><span class="line">        <span class="keyword">if</span> (state and CLOSED_MASK != <span class="number">0L</span>) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// ok - already closed</span></span><br><span class="line">        <span class="keyword">if</span> (state and FROZEN_MASK != <span class="number">0L</span>) <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// frozen -- try next</span></span><br><span class="line">        state or CLOSED_MASK <span class="comment">// try set closed bit</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Placeholder类，帮助标记状态的一个内部类"><a href="#Placeholder类，帮助标记状态的一个内部类" class="headerlink" title="Placeholder类，帮助标记状态的一个内部类"></a>Placeholder类，帮助标记状态的一个内部类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当扩容时，如果发现array里边有null，说明有别的线程更新了tail index，但还没有写入element，这个时候扩容线程会将array里这个slot</span></span><br><span class="line"><span class="comment">// 设置成Placeholder，来给其他线程在扩容后补写这个element</span></span><br><span class="line"><span class="comment">// Instance of this class is placed into array when we have to copy array, but addLast is in progress --</span></span><br><span class="line"><span class="comment">// it had already reserved a slot in the array (with null) and have not yet put its value there.</span></span><br><span class="line"><span class="comment">// Placeholder keeps the actual index (not masked) to distinguish placeholders on different wraparounds of array</span></span><br><span class="line"><span class="comment">// Internal because of inlining</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">Placeholder</span></span>(<span class="meta">@JvmField</span> <span class="keyword">val</span> index: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><h3 id="addLast-producer添加任务"><a href="#addLast-producer添加任务" class="headerlink" title="addLast - producer添加任务"></a>addLast - producer添加任务</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ADD_CLOSED | ADD_FROZEN | ADD_SUCCESS</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addLast</span><span class="params">(element: <span class="type">E</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    _state.loop &#123; state -&gt;</span><br><span class="line">        <span class="comment">// 如果当前状态为Frozen或是closed则返回失败原因</span></span><br><span class="line">        <span class="keyword">if</span> (state and (FROZEN_MASK or CLOSED_MASK) != <span class="number">0L</span>) <span class="keyword">return</span> state.addFailReason() <span class="comment">// cannot add</span></span><br><span class="line">        </span><br><span class="line">        state.withState &#123; head, tail -&gt;</span><br><span class="line">            <span class="keyword">val</span> mask = <span class="keyword">this</span>.mask <span class="comment">// manually move instance field to local for performance</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当queue只剩一个空位的时候，freeze并且扩容，因为single consumer的时候，可能会有一个element我们并不能overwrite</span></span><br><span class="line">            <span class="comment">// 在removeFirst的时候，因为removeFirst是先更新head index，再拿掉当前的element，所以需要进行extra margin of one element检查</span></span><br><span class="line">            <span class="comment">// If queue is Single-Consumer then there could be one element beyond head that we cannot overwrite,</span></span><br><span class="line">            <span class="comment">// so we check for full queue with an extra margin of one element</span></span><br><span class="line">            <span class="keyword">if</span> ((tail + <span class="number">2</span>) and mask == head and mask) <span class="keyword">return</span> ADD_FROZEN <span class="comment">// overfull, so do freeze &amp; copy</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// If queue is Multi-Consumer then the consumer could still have not cleared element</span></span><br><span class="line">            <span class="comment">// despite the above check for one free slot.</span></span><br><span class="line">            <span class="keyword">if</span> (!singleConsumer &amp;&amp; array[tail and mask].value != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是multi consumer，这个时候要两种情况</span></span><br><span class="line">                <span class="comment">// 1. 当queue的capacity &lt; 1024或整个queue已经用掉了一半的时候，进行扩容</span></span><br><span class="line">                <span class="comment">// 2. 否则，spin来等待consumer来拿任务</span></span><br><span class="line">                <span class="comment">// 这个case就是之前singleConsumer注释所说的，这个queue并不是lock free，因为这种情况会spin来等待consumer来take这个任务</span></span><br><span class="line">                <span class="comment">// There are two options in this situation</span></span><br><span class="line">                <span class="comment">// 1. Spin-wait until consumer clears the slot</span></span><br><span class="line">                <span class="comment">// 2. Freeze &amp; resize to avoid spinning</span></span><br><span class="line">                <span class="comment">// We use heuristic here to avoid memory-overallocation</span></span><br><span class="line">                <span class="comment">// Freeze &amp; reallocate when queue is small or more than half of the queue is used</span></span><br><span class="line">                <span class="keyword">if</span> (capacity &lt; MIN_ADD_SPIN_CAPACITY || (tail - head) and MAX_CAPACITY_MASK &gt; capacity shr <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ADD_FROZEN</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// otherwise spin</span></span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@loop</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取新的tail的位置</span></span><br><span class="line">            <span class="keyword">val</span> newTail = (tail + <span class="number">1</span>) and MAX_CAPACITY_MASK</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 原子操作，来确保state成功更新，如果compareAndSet返回false，此时state被别的thread更新，则继续loop</span></span><br><span class="line">            <span class="comment">// 因为这个library是target multi platform，这个地方的compareAndSet不止是Java的compareAndSet，也有JS和native</span></span><br><span class="line">            <span class="keyword">if</span> (_state.compareAndSet(state, state.updateTail(newTail))) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// successfully added</span></span><br><span class="line">                array[tail and mask].value = element</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 因为在set value的时候，有可能别的thread更新了状态，所以需要进行检查</span></span><br><span class="line">                <span class="comment">// could have been frozen &amp; copied before this item was set -- correct it by filling placeholder</span></span><br><span class="line">                <span class="keyword">var</span> cur = <span class="keyword">this</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 没有frozen，那说明addLast成功执行，exit loop</span></span><br><span class="line">                    <span class="keyword">if</span> (cur._state.value and FROZEN_MASK == <span class="number">0L</span>) <span class="keyword">break</span> <span class="comment">// all fine -- not frozen yet</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果当前的queue被frozen了，证明在当前thread set queue的时候，这个queue被扩容了</span></span><br><span class="line">                    <span class="comment">// 之前注释next的时候提到过，queue扩容时会生成一个新的queue object，把当前的queue._next指到queue上</span></span><br><span class="line">                    <span class="comment">// 因为在扩容时，新生成的queue array会判断每个element是否为null，如果不为null则copy，</span></span><br><span class="line">                    <span class="comment">// 如果为null，扩容线程知道有别的thread更新了tail index但还没来得及写入新的element进array里边</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果fillPlaceholder返回null，我们不需要再继续检查了，因为确认写入的element被成功复制到了新的queue里</span></span><br><span class="line">                    <span class="comment">// 如果返回的是新的queue，那么就说明，扩容线程复制的时候并没有复制当前element，fillPlaceholder进行了补写操作</span></span><br><span class="line">                    <span class="comment">// 当前element到扩容的array里边，这个时候，我们需要继续loop，因为可能扩容线程扩容之后，又有别的线程进行了扩容</span></span><br><span class="line">                    <span class="comment">// 这时loop会持续补写直到我们发现不需要array里的值不是Placeholder instance为止</span></span><br><span class="line">                    cur = cur.next().fillPlaceholder(tail, element) ?: <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ADD_SUCCESS <span class="comment">// added successfully</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fillPlaceholder</span><span class="params">(index: <span class="type">Int</span>, element: <span class="type">E</span>)</span></span>: Core&lt;E&gt;? &#123;</span><br><span class="line">    <span class="comment">// 获取这个index里边存的值</span></span><br><span class="line">    <span class="keyword">val</span> old = array[index and mask].value</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * addLast actions: addLast的操作</span></span><br><span class="line"><span class="comment">     * 1) Commit tail slot 更新tail的index，也就是allocate tail的slot</span></span><br><span class="line"><span class="comment">     * 2) Write element to array slot 写入element到array里边</span></span><br><span class="line"><span class="comment">     * 3) Check for array copy 检查array是否扩容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在操作过程中如果第2步和第3步过程中，发生了扩容，consumer有可能已经获取了这个element</span></span><br><span class="line"><span class="comment">     * If copy happened between 2 and 3 then the consumer might have consumed our element,</span></span><br><span class="line"><span class="comment">     * then another producer might have written its placeholder in our slot, so we should</span></span><br><span class="line"><span class="comment">     * perform *unique* check that current placeholder is our to avoid overwriting another producer placeholder</span></span><br><span class="line"><span class="comment">     * 如果Placeholder里边的index是方法传入的index，这时我们确定这个Placeholder是当前线程的Placeholder，而不是其他producer的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (old <span class="keyword">is</span> Placeholder &amp;&amp; old.index == index) &#123;</span><br><span class="line">        <span class="comment">// 因为扩容的时候，扩容线程复制了老的array，此时，当前producer线程并没有写入新的element，这个操作是把element写进扩容后的array</span></span><br><span class="line">        array[index and mask].value = element</span><br><span class="line">        <span class="comment">// we&#x27;ve corrected missing element, should check if that propagated to further copies, just in case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回null，这种情况是扩容线程在扩容的时候，已经看到了producer线程写入的新element</span></span><br><span class="line">    <span class="comment">// 这个时候我们不需要做进行next的check，因为之后即便再有扩容，已经写进当前扩容的element都会被复制到之后的扩容array里</span></span><br><span class="line">    <span class="comment">// it is Ok, no need for further action</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeFistOrNull-consumer来拿任务，如果没有任务，则返回null"><a href="#removeFistOrNull-consumer来拿任务，如果没有任务，则返回null" class="headerlink" title="removeFistOrNull consumer来拿任务，如果没有任务，则返回null"></a>removeFistOrNull consumer来拿任务，如果没有任务，则返回null</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// REMOVE_FROZEN | null (EMPTY) | E (SUCCESS)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeFirstOrNull</span><span class="params">()</span></span>: Any? &#123;</span><br><span class="line">    _state.loop &#123; state -&gt;</span><br><span class="line">        <span class="comment">// 当前queue已被frozen，发生了扩容，返回这个状态，让调用这个方法的consumer决定该做什么</span></span><br><span class="line">        <span class="keyword">if</span> (state and FROZEN_MASK != <span class="number">0L</span>) <span class="keyword">return</span> REMOVE_FROZEN <span class="comment">// frozen -- cannot modify</span></span><br><span class="line">        state.withState &#123; head, tail -&gt;</span><br><span class="line">            <span class="comment">// 当前queue为空，返回null</span></span><br><span class="line">            <span class="keyword">if</span> ((tail and mask) == (head and mask)) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// empty</span></span><br><span class="line">            <span class="keyword">val</span> element = array[head and mask].value</span><br><span class="line">            <span class="keyword">if</span> (element == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是single consumer，则producer没有完成加入element</span></span><br><span class="line">                <span class="comment">// If queue is Single-Consumer, then element == null only when add has not finished yet</span></span><br><span class="line">                <span class="keyword">if</span> (singleConsumer) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// consider it not added yet</span></span><br><span class="line">                <span class="comment">// 如果是multi consumer，我们需要spin，来尝试继续获取element，这个是之前说的这个queue会spin</span></span><br><span class="line">                <span class="comment">// retry (spin) until consumer adds it</span></span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@loop</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前element是Placeholder，说明producer还没来得及补写扩容之后的queue array，这时我们认为状态是not added yet，所以返回null</span></span><br><span class="line">            <span class="comment">// element == Placeholder can only be when add has not finished yet</span></span><br><span class="line">            <span class="keyword">if</span> (element <span class="keyword">is</span> Placeholder) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// consider it not added yet</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 我们这个地方不能直接更新element为null，因为会有一个edge case</span></span><br><span class="line">            <span class="comment">// 情况为：当前有两个线程，一个producer线程即将进行扩容，一个consumer线程，</span></span><br><span class="line">            <span class="comment">// 假设consumer线程直接把array[head]变成了null，之后producer线程进行扩容，因为扩容时，null的element会被当做是别的producer线程还没来得及写入的element</span></span><br><span class="line">            <span class="comment">// 这时扩容线程把这个element变成了placeholder，这回break queue的状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正确操作是先更新head index，如果更新成功，再将array[previous head]设成null，因为这个时候即便producer线程进行扩容，也只会copy新的head到tail的elements</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// we cannot put null into array here, because copying thread could replace it with Placeholder and that is a disaster</span></span><br><span class="line">            <span class="keyword">val</span> newHead = (head + <span class="number">1</span>) and MAX_CAPACITY_MASK</span><br><span class="line">            <span class="keyword">if</span> (_state.compareAndSet(state, state.updateHead(newHead))) &#123;</span><br><span class="line">                <span class="comment">// Array could have been copied by another thread and it is perfectly fine, since only elements</span></span><br><span class="line">                <span class="comment">// between head and tail were copied and there are no extra steps we should take here</span></span><br><span class="line">                array[head and mask].value = <span class="literal">null</span> <span class="comment">// now can safely put null (state was updated)</span></span><br><span class="line">                <span class="keyword">return</span> element <span class="comment">// successfully removed in fast-path</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// multi consumer的时候需要spin来确保当前head不被别的consumer拿掉</span></span><br><span class="line">            <span class="comment">// Multi-Consumer queue must retry this loop on CAS failure (another consumer might have removed element)</span></span><br><span class="line">            <span class="keyword">if</span> (!singleConsumer) <span class="keyword">return</span><span class="symbol">@loop</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果是single consumer的case，之前的compareAndSet失败是因为producer线程进行了扩容</span></span><br><span class="line">            <span class="comment">// 这个时候需要从扩容之后的queue里边拿到element，并且更新head</span></span><br><span class="line">            <span class="comment">// Single-consumer queue goes to slow-path for remove in case of interference</span></span><br><span class="line">            <span class="keyword">var</span> cur = <span class="keyword">this</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="meta">@Suppress(<span class="meta-string">&quot;UNUSED_VALUE&quot;</span>)</span></span><br><span class="line">                cur = cur.removeSlowPath(head, newHead) ?: <span class="keyword">return</span> element</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeSlowPath</span><span class="params">(oldHead: <span class="type">Int</span>, newHead: <span class="type">Int</span>)</span></span>: Core&lt;E&gt;? &#123;</span><br><span class="line">    _state.loop &#123; state -&gt;</span><br><span class="line">        state.withState &#123; head, _ -&gt;</span><br><span class="line">            <span class="comment">// Extra检查，head值不应该变，如果变化了，说明并不是single consumer，</span></span><br><span class="line">            <span class="comment">// 这个时候会报错，因为single consumer的操作和multi consumer操作不一样，assumption不正确queue的操作就不正确</span></span><br><span class="line">            assert &#123; head == oldHead &#125; <span class="comment">// &quot;This queue can have only one consumer&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Frozen状态说明扩容了，这个时候要去point到扩容之后的queue</span></span><br><span class="line">            <span class="keyword">if</span> (state and FROZEN_MASK != <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// state was already frozen, so removed element was copied to next</span></span><br><span class="line">                <span class="keyword">return</span> next() <span class="comment">// continue to correct head in next</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原子操作更新head，如果这个时候更新成功，则将head 设成null</span></span><br><span class="line">            <span class="comment">// 更新不成功，说明有别的producer线程又进行了扩容，这个时候需要继续loop，直到head成功被更新，也就是没有别的线程扩容</span></span><br><span class="line">            <span class="keyword">if</span> (_state.compareAndSet(state, state.updateHead(newHead))) &#123;</span><br><span class="line">                array[head and mask].value = <span class="literal">null</span> <span class="comment">// now can safely put null (state was updated)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容逻辑，在addLast的时候，满足之前提到的条件会进行扩容"><a href="#扩容逻辑，在addLast的时候，满足之前提到的条件会进行扩容" class="headerlink" title="扩容逻辑，在addLast的时候，满足之前提到的条件会进行扩容"></a>扩容逻辑，在addLast的时候，满足之前提到的条件会进行扩容</h3><p>扩容实际是copy之前的array里边的元素到新的array里边</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前queue的next或是copy，如果有next则说明别的线程扩容了，如果next是null，则进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: LockFreeTaskQueueCore&lt;E&gt; = allocateOrGetNextCopy(markFrozen())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把当前state标记成frozen，提示其他线程，这个queue已经过期（有新的扩容queue生成）</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">markFrozen</span><span class="params">()</span></span>: <span class="built_in">Long</span> =</span><br><span class="line">    _state.updateAndGet &#123; state -&gt;</span><br><span class="line">        <span class="keyword">if</span> (state and FROZEN_MASK != <span class="number">0L</span>) <span class="keyword">return</span> state <span class="comment">// already marked</span></span><br><span class="line">        state or FROZEN_MASK</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">allocateOrGetNextCopy</span><span class="params">(state: <span class="type">Long</span>)</span></span>: Core&lt;E&gt; &#123;</span><br><span class="line">    _next.loop &#123; next -&gt;</span><br><span class="line">        <span class="comment">// 如果next不为null，期间已有别的线程扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (next != <span class="literal">null</span>) <span class="keyword">return</span> next <span class="comment">// already allocated &amp; copied</span></span><br><span class="line">        <span class="comment">// 如果是null，则进行扩容</span></span><br><span class="line">        <span class="comment">// 因为在扩容时，可能有别的线程更改了状态，所以compareAndSet失败的时候，next依旧为null，这时进行继续loop check</span></span><br><span class="line">        <span class="comment">// 这个地方也是个spin</span></span><br><span class="line">        _next.compareAndSet(<span class="literal">null</span>, allocateNextCopy(state))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">allocateNextCopy</span><span class="params">(state: <span class="type">Long</span>)</span></span>: Core&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 生成一个新的Queue，容量是之前的两倍</span></span><br><span class="line">    <span class="keyword">val</span> next = LockFreeTaskQueueCore&lt;E&gt;(capacity * <span class="number">2</span>, singleConsumer)</span><br><span class="line">    state.withState &#123; head, tail -&gt;</span><br><span class="line">        <span class="keyword">var</span> index = head</span><br><span class="line">        <span class="comment">// 扩容逻辑，range是head index到tail index</span></span><br><span class="line">        <span class="comment">// 之前提到过，removeFirst会先更新head index，addLast会先更新tail index</span></span><br><span class="line">        <span class="keyword">while</span> (index and mask != tail and mask) &#123;</span><br><span class="line">            <span class="comment">// 如果array[index]不为null，则复制到新的array，如果是null，说明此时producer线程更新完tail index后还没写入array</span></span><br><span class="line">            <span class="comment">// 这个时候我们创建一个Placeholder，来给producer线程补写element进扩容后的array</span></span><br><span class="line">            <span class="comment">// replace nulls with placeholders on copy</span></span><br><span class="line">            <span class="keyword">val</span> value = array[index and mask].value ?: Placeholder(index)</span><br><span class="line">            next.array[index and next.mask].value = value</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新状态，reset frozen flag为0</span></span><br><span class="line">        next._state.value = state wo FROZEN_MASK</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后LockFreeTaskQueue，这里边的逻辑比较straight-forward"><a href="#最后LockFreeTaskQueue，这里边的逻辑比较straight-forward" class="headerlink" title="最后LockFreeTaskQueue，这里边的逻辑比较straight forward"></a>最后LockFreeTaskQueue，这里边的逻辑比较straight forward</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeTaskQueue</span>&lt;<span class="type">E : Any</span>&gt;</span>(</span><br><span class="line">    singleConsumer: <span class="built_in">Boolean</span> <span class="comment">// true when there is only a single consumer (slightly faster &amp; lock-free)</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _cur = atomic(Core&lt;E&gt;(Core.INITIAL_CAPACITY, singleConsumer))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: it is not atomic w.r.t. remove operation (remove can transiently fail when isEmpty is false)</span></span><br><span class="line">    <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = _cur.value.isEmpty</span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span> <span class="keyword">get</span>() = _cur.value.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 不断尝试close当前queue，因为可能发生扩容，所以要不断spin来尝试</span></span><br><span class="line">        _cur.loop &#123; cur -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cur.close()) <span class="keyword">return</span> <span class="comment">// closed this copy</span></span><br><span class="line">            _cur.compareAndSet(cur, cur.next()) <span class="comment">// move to next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addLast</span><span class="params">(element: <span class="type">E</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        _cur.loop &#123; cur -&gt;</span><br><span class="line">            <span class="comment">// addLast</span></span><br><span class="line">            <span class="keyword">when</span> (cur.addLast(element)) &#123;</span><br><span class="line">                Core.ADD_SUCCESS -&gt; <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                Core.ADD_CLOSED -&gt; <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                <span class="comment">// Frozen状态说明有扩容，获取扩容后的queue，这个地方进行了spin</span></span><br><span class="line">                Core.ADD_FROZEN -&gt; _cur.compareAndSet(cur, cur.next()) <span class="comment">// move to next</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeFirstOrNull</span><span class="params">()</span></span>: E? &#123;</span><br><span class="line">        _cur.loop &#123; cur -&gt;</span><br><span class="line">            <span class="keyword">val</span> result = cur.removeFirstOrNull()</span><br><span class="line">            <span class="keyword">if</span> (result !== Core.REMOVE_FROZEN) <span class="keyword">return</span> result <span class="keyword">as</span> E?</span><br><span class="line">            <span class="comment">// Frozen状态说明有扩容，获取扩容后的queue，这个地方进行了spin</span></span><br><span class="line">            _cur.compareAndSet(cur, cur.next())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used for validation in tests only</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">map</span><span class="params">(transform: (<span class="type">E</span>) -&gt; <span class="type">R</span>)</span></span>: List&lt;R&gt; = _cur.value.map(transform)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used for validation in tests only</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isClosed</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = _cur.value.isClosed()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本每一个要处理异步编程的library都需要有个queue来维护任务，Kotlin这个coroutine因为要target multiplatform，<br>写这么个queue要考虑很多case，因为有的platform可能是single consumer，有的又是multi consumer，<br>为了这个还写了不同的处理逻辑，也算是做到极致了。</p><p>对比别的library可能值需要做到MPSC，比如Reactor的 <a href="https://github.com/reactor/reactor-core/blob/933fc90572194db080590e3b2f96b91147aebb4a/reactor-core/src/main/java/reactor/util/concurrent/MpscLinkedQueue.java">MpscLinkedQueue</a><br>，kotlin coroutine的queue的逻辑要复杂得多。</p><p>在效率方面，如果是对于target是JVM的，应该跟用线程池实现NIO的效率差不多，我记得之前看扔物线的 <a href="https://youtu.be/LKsGkEsEE7w">Kotlin的协程</a><br>提到过这个概念，Kotlin的coroutine并不会比线程池更效率，因为它底层也是这么实现的。</p><p>而且从另一个角度看，在JS里，这种在Kotlin维护一个task queue，未必比native的event loop更效率，<br>因为Kotlin最终是transpile成了JS，而Node里边的event loop是libuv用C实现的。</p><p>不知道这个想法对不对。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lock-Free-Task-Queue&quot;&gt;&lt;a href=&quot;#Lock-Free-Task-Queue&quot; class=&quot;headerlink&quot; title=&quot;Lock Free Task Queue&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.co</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>视频类应用的体验总结</title>
    <link href="https://blog.yuanchenxi95.com/2021/06/27/%E8%A7%86%E9%A2%91%E7%B1%BB%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.yuanchenxi95.com/2021/06/27/%E8%A7%86%E9%A2%91%E7%B1%BB%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-28T06:13:29.000Z</published>
    <updated>2025-02-14T04:48:41.017Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章将总结一些个人对于以下视频类应用的体验：</p><ul><li>Bilibili</li><li>抖音 </li><li>YouTube</li><li>快手</li><li>TikTok</li></ul><h2 id="Bilibili"><a href="#Bilibili" class="headerlink" title="Bilibili"></a>Bilibili</h2><p>在上个时代的视频类应用中，B站应该算是唯一一个能破局的应用了。<br>对比爱奇艺，优酷，和腾讯视频依旧被禁锢在原有的领域中，今天的B站已经成为能和抖音和快手竞争的内容提供平台，<br>也是目前国内最像YouTube的一家应用。对比其余两家短视频作为主力的应用，B站接近五百亿美元的市值，个人认为还是偏低。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>B站除了拥有大量优秀的内容创作者之外，还拥有一个非常庞大，活跃，年轻的社区。<br>优秀的内容创作和优秀的弹幕评论是相辅相成的存在，对比其余任何的视频平台，B站的弹幕文化都是不可复制的。<br>一个优秀的社区不是靠传统互联网打法，例如补贴和引流，就能够建成的。<br>我最近再追的一个动漫，一刷在其它网站看完之后，二刷会去用B站看，尽管由于某种原因非常麻烦。<br>因为B站的弹幕能提醒我注意很多我自己看没有注意到的细节，评论区也有很多热心用户提供很完善的总结和分析。<br>单单这一项就是其余所有社区无法提供的。</p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>B站的推荐系统可以算是这个列表中做的最差的了，每次点开B站的app，主页的推荐大部分都是一些鸡肋的推荐。<br>这些推荐可以看出是符合我关注的方向的，但大部分都是些雷同无味的视频，可能也和我B站刻意养成的画像有关。<br>21年春节的时候，每次打开app，都是三兄弟的拜年视频，虽然每个拜年视频我都会点进去看完，<br>但这些视频也只是充当娱乐和和恶搞，没有任何营养。</p><h2 id="抖音"><a href="#抖音" class="headerlink" title="抖音"></a>抖音</h2><p>抖音作为视频类应用中的后来居上的领军，其在产品设计中的各个决策算是这个时代的巅峰，<br>抖音的推荐算法也是个人觉得所有涉及推荐算法领域的app里最好的。</p><h2 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h2><ol><li><p>点开App即播放，零上手成本。<br>这种设计无论是对不熟悉手机操作的人群，还是对硬核手机用户，都能让用户打开app就留在app。</p></li><li><p>当点视频播放完成后循环播放。<br>有很多短视频类应用，在播放完当前视频后，会自动播放下一个视频，例如微博和QQ空间中的短视频。<br>个人觉得这种做法除了增加总体视频的播放量之外，没有什么好处。而且这种做法很难收集到用户对于一个视频的反馈，<br>用户对当前视频不感兴趣，很可能也就等视频播放完跳到下一个视频。<br>而循环播放的好处就在于，用户如果对当前视频不感兴趣，就必须要手动去切换到下一个视频，<br>而且能收集到用户具体在那一个点判断出对这个视频不感兴趣。</p></li><li><p>视频的播放进度选择按钮非常的小，对用户来说很难跳过视频的一段内容。<br>这是个很有意思的设计，大部分音视频播放应用都会提供一个很方便的选择播放进度的交互系统，<br>除了一个进度条和当前进度按钮，很多视频类应用还提供了更便捷的操作，比如B站的屏幕向左右滑动，YouTube的双击半边屏幕。<br>抖音则选择了反其道而行，把按钮设计的非常小，尽量不让用户注意到有这么一个进度选择功能。<br>可能从最初的短视频角度来讲，进度选择没有很大的意义，但现在抖音上接近十分钟的长视频也比比皆是，抖音依旧保留了这个设计。<br>个人感觉，目的是为了让用户尽量看完全部视频，或是对当前内容不感兴趣就直接划走。如果用户做一个很难操作还要跳过一部分内容，<br>其实从数据收集的角度来讲，用户的这个行为也十分珍贵，可以给视频创作者提供很好的feedback。</p></li></ol><h2 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h2><p>抖音的推荐系统真的是堪称完美</p><ol><li><p>同类型视频的推荐。<br>我不知道字节的推荐系统具体是如何实现的，有多少人为干预。抖音这个同类视频以及创作者的推荐算是所有应用里计算的比较精准的了。<br>项亮曾表达过这么一个观点，最好的推荐系统应该只有两个ID，一个是用户ID，另一个是内容ID。<br>不太清楚字节在工程项目里是怎么做这些同类内容的归纳和判断，如果是纯靠用户行为来归纳，那做到这种程度可是真的太厉害了。</p><p>这个推荐系统同样有个瑕疵，归为同类的视频创作者，水平可能参差不齐。<br>抖音上有很多英语教学类的创作者，这些创作者的水平差距真的是天上地下，有接受过专业训练的英语教师，有从事英语教学研究的PhD，<br>有专业的会说中文的英语外教。但同样也有些自己英语的都说不明白的二流创作者。<br>对于大部分抖音用户，可能无法区分这些创作者水平的差异，导致的结果是推荐系统无法收集到足够的数据来区分这些创作者。</p></li><li><p>非兴趣方向的视频推荐<br>几乎所有推荐系统只推荐兴趣相关的内容，这个问题最严重的应该是YouTube，会在YouTube section下边做详细讨论。<br>这种推荐算法自以为是为了尽可能提升用户的使用时长，因为这些都是用户感兴趣的。但同类视频也总有一个度，看多了也会出现疲劳。<br>抖音在这点上做的非常好，除了推荐用户已知兴趣点之外，还会推荐很多未知兴趣点。<br>我在抖音上的推荐视频里，意外的返现了很多之前从未关注的领域，<br>比如有些钓鱼类博主，维修类（城阳电工电路），航运类（李船长笔记），美食类，会计金融，航空航天。<br>这些分类，在其他所有视频平台都没有过相关的推荐，这些真的很有意思。<br>“Some people say, “Give the customers what they want.” But that’s not my approach.<br>Our job is to figure out what they’re going to want before they do.” – Steve Jobs</p></li></ol><h3 id="缺失的功能"><a href="#缺失的功能" class="headerlink" title="缺失的功能"></a>缺失的功能</h3><p>抖音的一个问题是，用户没办法去设置对一些博主的强订阅。<br>我关注了许多做动漫，电视剧剧情解说的博主，这些博主通常一天更新两三集。<br>很多时候，我即便从关注的section去刷，也很难每天刷到所有我想看的博主。<br>我不太清楚是不是本身产品设计就是不允许用户自己有很强的订阅性，可能他们本身就想尽可能使用推荐系统来决定用户的观看列表。</p><h2 id="YouTube"><a href="#YouTube" class="headerlink" title="YouTube"></a>YouTube</h2><p>YouTube作为一个老牌的原创视频平台，这么多年屹立不倒，在抖音出现之前，甚至都没有个像样的挑战者。</p><h3 id="综合类的图书馆"><a href="#综合类的图书馆" class="headerlink" title="综合类的图书馆"></a>综合类的图书馆</h3><p>与其说YouTube是一个视频平台，不如说它是一个大型的综合类图书馆，只是这些图书不是传统意义上的纸质书。<br>You literally can find anything on YouTube.<br>作为一个百科式的平台，YouTube已经积累的视频内容使其的地位这么多年一直无法被撼动。</p><h3 id="丰厚的广告收益分成"><a href="#丰厚的广告收益分成" class="headerlink" title="丰厚的广告收益分成"></a>丰厚的广告收益分成</h3><p>YouTube能吸引这么多的创作者，可能还是因为平台确实给了这些人足够的回报。<br>我记得之前看李自然一期节目里提到过B站的创作者激励计划和YouTube广告收益的对比，这个B站给的分成对比来看确实有点寒酸。</p><h3 id="YouTube的用户体验"><a href="#YouTube的用户体验" class="headerlink" title="YouTube的用户体验"></a>YouTube的用户体验</h3><p>从交互来讲，YouTube的app做的真的一般，不知道这个是不是这么多年以来测试下来的最优结果。YouTube的评论区功能尤其难用。<br>首页推荐列表的设计很不错，YouTube的推荐列表，每个视频基本占据了1&#x2F;2一个窗口。<br>对比其他视频类应用左右两列，拥挤的塞下一堆视频来讲。YouTube的列表，在手机屏幕内只展示一两个视频其实很不错，<br>能让用户去了解这个推荐视频的一些简要信息。</p><h3 id="推荐系统-1"><a href="#推荐系统-1" class="headerlink" title="推荐系统"></a>推荐系统</h3><p>YouTube的推荐系统可能真的是把算法用到了极致，但这反而成了它的问题。<br>个人体验，YouTube几乎每一个推荐的视频都是我关注的领域，基本上没出现过未知领域的推荐。<br>这样的推荐反而造就了YouTube的信息茧房，让我很难去发现一些新鲜的内容。<br>大部分时候，这些推荐的内容还都会趋于同质化。</p><p>很多时候，我现在YouTube关注的博主都是从抖音看到了相关的视频去主动关注的。<br>这其实很说明问题，作为平台，它确实有所有我感兴趣的内容，但作为平台，它却没能把这些优秀的创作者推荐给我。<br>说明推荐系统并没有认为，我可能是potential对这些内容感兴趣。</p><h2 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h2><p>快手是一个很有意思的应用，只要用一两次快手，就很容易理解快手的海量用户是如何吸引来的。<br>这个平台如果一直以这种内容为主，很难打破原有的壁垒。<br>没有营养的休闲内容确实能让人放松，毕竟这个应用能把自己定位成一个类游戏的app，同样能实现很高的DAU和收入。<br>之前看到一篇文章，<a href="https://mp.weixin.qq.com/s/elpCuBHACXnpIboTYZIl5A">快手的隐忧：成败皆老铁</a>。<br>这个其实把快手的痛处说的一针见血，快手能否破局其实也就看它自己的作为了。</p><h2 id="TikTok"><a href="#TikTok" class="headerlink" title="TikTok"></a>TikTok</h2><p>我用TikTok并不多，也不好做很多的评价。TikTok的感觉其实和抖音大相径庭，抖音更像是一个综合性的大型内容平台，<br>而TikTok却更像是一个海外版的快手。或许可能是因为海外YouTube的地位难以撼动，或许因为TikTok海外的运营还不够成熟。<br>我是更希望看到TikTok能更像抖音，而不是快手。</p>]]></content>
    
    
    <summary type="html">本篇文章将总结一些个人对于以下视频类应用的体验： Bilibili，抖音，YouTube，快手，TikTok</summary>
    
    
    
    
    <category term="Thoughts" scheme="https://blog.yuanchenxi95.com/tags/Thoughts/"/>
    
    <category term="Reviews" scheme="https://blog.yuanchenxi95.com/tags/Reviews/"/>
    
    <category term="Video Apps" scheme="https://blog.yuanchenxi95.com/tags/Video-Apps/"/>
    
    <category term="Summary" scheme="https://blog.yuanchenxi95.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>My First Blog</title>
    <link href="https://blog.yuanchenxi95.com/2021/06/23/My-First-Blog/"/>
    <id>https://blog.yuanchenxi95.com/2021/06/23/My-First-Blog/</id>
    <published>2021-06-23T08:05:40.000Z</published>
    <updated>2025-02-14T04:48:41.017Z</updated>
    
    <content type="html"><![CDATA[<p>This is my first blog.</p><p>这是我的第一篇博客。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;This is my first blog.&lt;/p&gt;
&lt;p&gt;这是我的第一篇博客。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
