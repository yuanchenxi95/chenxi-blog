<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Kotlin Coroutine LockFreeTaskQueue 源码注释 | Welcome to my Qzone</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Lock Free Task Queue对 Kotlin Coroutine 的Lock Free Task Queue的注释 常量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Supp">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin Coroutine LockFreeTaskQueue 源码注释">
<meta property="og:url" content="https://blog.yuanchenxi95.com/2021/11/09/Kotlin-Coroutine-LockFreeTaskQueue-%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A/index.html">
<meta property="og:site_name" content="Welcome to my Qzone">
<meta property="og:description" content="Lock Free Task Queue对 Kotlin Coroutine 的Lock Free Task Queue的注释 常量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Supp">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-11-10T04:03:21.000Z">
<meta property="article:modified_time" content="2025-02-14T04:48:41.017Z">
<meta property="article:author" content="Chenxi Yuan">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Welcome to my Qzone" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome to my Qzone</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.yuanchenxi95.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Kotlin-Coroutine-LockFreeTaskQueue-源码注释" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/09/Kotlin-Coroutine-LockFreeTaskQueue-%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A/" class="article-date">
  <time class="dt-published" datetime="2021-11-10T04:03:21.000Z" itemprop="datePublished">2021-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Kotlin Coroutine LockFreeTaskQueue 源码注释
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Lock-Free-Task-Queue"><a href="#Lock-Free-Task-Queue" class="headerlink" title="Lock Free Task Queue"></a><a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines/blob/5e870c11311b3bfd58f0557c651f1d877e9e5827/kotlinx-coroutines-core/common/src/internal/LockFreeTaskQueue.kt">Lock Free Task Queue</a></h2><p>对 <a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx.coroutines">Kotlin Coroutine</a> 的Lock Free Task Queue的注释</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="meta-string">&quot;PrivatePropertyName&quot;</span>, <span class="meta-string">&quot;MemberVisibilityCanBePrivate&quot;</span>)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> INITIAL_CAPACITY = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为LockFreeTaskQueue用一个Atomic Long存储queue的state，来确保每次更新state都是原子操作</span></span><br><span class="line">    <span class="comment">// - head: 30 bit，用来记录circular queue的head index</span></span><br><span class="line">    <span class="comment">// - tail: 30 bit，用来记录circular queue的tail index</span></span><br><span class="line">    <span class="comment">// - frozen: 1 bit，indicate当前的queue是否被冻结</span></span><br><span class="line">    <span class="comment">// - closed: 1 bit, indicate当前的queue是否被close</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> CAPACITY_BITS = <span class="number">30</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> MAX_CAPACITY_MASK = (<span class="number">1</span> shl CAPACITY_BITS) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> HEAD_SHIFT = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Head Mask: 用来从Long state里获取head的Int值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> HEAD_MASK = MAX_CAPACITY_MASK.toLong() shl HEAD_SHIFT</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> TAIL_SHIFT = HEAD_SHIFT + CAPACITY_BITS</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Tail Mask: 用来从Long state里获取tail的Int值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> TAIL_MASK = MAX_CAPACITY_MASK.toLong() shl TAIL_SHIFT</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> FROZEN_SHIFT = TAIL_SHIFT + CAPACITY_BITS</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Frozen Mask: 用来从Long state里获取frozen的flag </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> FROZEN_MASK = <span class="number">1L</span> shl FROZEN_SHIFT</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> CLOSED_SHIFT = FROZEN_SHIFT + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Closed Mask: 用来从Long state里获取closed的flag</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> CLOSED_MASK = <span class="number">1L</span> shl CLOSED_SHIFT</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> MIN_ADD_SPIN_CAPACITY = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> REMOVE_FROZEN = Symbol(<span class="string">&quot;REMOVE_FROZEN&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add to queue的enum状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成功Add to the queue</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> ADD_SUCCESS = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 失败：queue已经为frozen状态</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> ADD_FROZEN = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 失败：queue已经被close</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> ADD_CLOSED = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">wo</span><span class="params">(other: <span class="type">Long</span>)</span></span> = <span class="keyword">this</span> and other.inv()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (this wo HEAD_MASK): 抹除Long state里head的值</span></span><br><span class="line">    <span class="comment">// (newHead.toLong() shl HEAD_SHIFT): 获取一个新的Long，并写入新的head值</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">updateHead</span><span class="params">(newHead: <span class="type">Int</span>)</span></span> = (<span class="keyword">this</span> wo HEAD_MASK) or (newHead.toLong() shl HEAD_SHIFT)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (this wo TAIL_MASK): 抹除Long state里tail的值</span></span><br><span class="line">    <span class="comment">// (newHead.toLong() shl HEAD_SHIFT): 获取一个新的Long，并写入新的tail值</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">updateTail</span><span class="params">(newTail: <span class="type">Int</span>)</span></span> = (<span class="keyword">this</span> wo TAIL_MASK) or (newTail.toLong() shl TAIL_SHIFT)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="built_in">Long</span>.<span class="title">withState</span><span class="params">(block: (<span class="type">head</span>: <span class="type">Int</span>, <span class="type">tail</span>: <span class="type">Int</span>) -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="comment">// 从Long state读出head值，并转化为Int</span></span><br><span class="line">        <span class="keyword">val</span> head = ((<span class="keyword">this</span> and HEAD_MASK) shr HEAD_SHIFT).toInt()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从Long state读出tail值，并转化为Int</span></span><br><span class="line">        <span class="keyword">val</span> tail = ((<span class="keyword">this</span> and TAIL_MASK) shr TAIL_SHIFT).toInt()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> block(head, tail)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取state里的失败原因，如果是Close返回ADD_CLOSED状态，否则返回ADD_FROZEN状态</span></span><br><span class="line">    <span class="comment">// FROZEN | CLOSED</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="built_in">Long</span>.<span class="title">addFailReason</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span> (<span class="keyword">this</span> and CLOSED_MASK != <span class="number">0L</span>) ADD_CLOSED <span class="keyword">else</span> ADD_FROZEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Internal变量"><a href="#Internal变量" class="headerlink" title="Internal变量"></a>Internal变量</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> Core&lt;E&gt; = LockFreeTaskQueueCore&lt;E&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeTaskQueueCore</span>&lt;<span class="type">E : Any</span>&gt;</span>(</span><br><span class="line">    <span class="comment">// Queue最大存储的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Indicate这个queue是否只有一个consumer，这个field非常重要</span></span><br><span class="line">    <span class="comment">// note 2 翻译：</span></span><br><span class="line">    <span class="comment">// 当这个queue有多个consumer的时候，这个queue并不是Lock Free</span></span><br><span class="line">    <span class="comment">// consumer spins直到producer完成它的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> singleConsumer: <span class="built_in">Boolean</span> <span class="comment">// true when there is only a single consumer (slightly faster)</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// Mask: 用来获取queue的实际head index和tail index</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mask = capacity - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在queue扩容时，会将新生成的queue存储在这个Atomic Ref里边</span></span><br><span class="line">    <span class="comment">// 如果在扩容期间，有别的thread对当前的queue进行操作，在操作完成时，会检查当前的queue的next是否为空</span></span><br><span class="line">    <span class="comment">// 如果是null，证明此时没有扩容，写入的atomic Long state成功，queue里的item操作也成功</span></span><br><span class="line">    <span class="comment">// 如果不为null，需要将状态更新到新生成的queue中，也就是next ref的queue，</span></span><br><span class="line">    <span class="comment">// 更新完成后，需要再次检查next的next是否为空，如果不为空，则说明queue再次扩容，</span></span><br><span class="line">    <span class="comment">// 需要重新进行更新，直到更新完成后的next为null。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _next = atomic&lt;Core&lt;E&gt;?&gt;(<span class="literal">null</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Atomic Long state，用来记录queue的状态，包括：head index，tail index，是否frozen，是否closed</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _state = atomic(<span class="number">0L</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Circular Queue array，生成一个长度为capacity的array，每个item都是一个atomic ref到null</span></span><br><span class="line">    <span class="comment">// 这个queue里边存储的是需要执行的任务，consumer会从queue的head读任务出来，producer会将任务加到tail的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> array = atomicArrayOfNulls&lt;Any?&gt;(capacity)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...省略代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态方法"><a href="#状态方法" class="headerlink" title="状态方法"></a>状态方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当head index == tail index的时候，queue为空</span></span><br><span class="line"><span class="comment">// Note: it is not atomic w.r.t. remove operation (remove can transiently fail when isEmpty is false)</span></span><br><span class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = _state.value.withState &#123; head, tail -&gt; head == tail &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tail index - head index，然后mask by MAX_CAPACITY_MASK为当前queue的size</span></span><br><span class="line"><span class="keyword">val</span> size: <span class="built_in">Int</span> <span class="keyword">get</span>() = _state.value.withState &#123; head, tail -&gt; (tail - head) and MAX_CAPACITY_MASK &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前queue是否未关闭状态</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    _state.update &#123; state -&gt;</span><br><span class="line">        <span class="keyword">if</span> (state and CLOSED_MASK != <span class="number">0L</span>) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// ok - already closed</span></span><br><span class="line">        <span class="keyword">if</span> (state and FROZEN_MASK != <span class="number">0L</span>) <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// frozen -- try next</span></span><br><span class="line">        state or CLOSED_MASK <span class="comment">// try set closed bit</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Placeholder类，帮助标记状态的一个内部类"><a href="#Placeholder类，帮助标记状态的一个内部类" class="headerlink" title="Placeholder类，帮助标记状态的一个内部类"></a>Placeholder类，帮助标记状态的一个内部类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当扩容时，如果发现array里边有null，说明有别的线程更新了tail index，但还没有写入element，这个时候扩容线程会将array里这个slot</span></span><br><span class="line"><span class="comment">// 设置成Placeholder，来给其他线程在扩容后补写这个element</span></span><br><span class="line"><span class="comment">// Instance of this class is placed into array when we have to copy array, but addLast is in progress --</span></span><br><span class="line"><span class="comment">// it had already reserved a slot in the array (with null) and have not yet put its value there.</span></span><br><span class="line"><span class="comment">// Placeholder keeps the actual index (not masked) to distinguish placeholders on different wraparounds of array</span></span><br><span class="line"><span class="comment">// Internal because of inlining</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">Placeholder</span></span>(<span class="meta">@JvmField</span> <span class="keyword">val</span> index: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>


<h3 id="addLast-producer添加任务"><a href="#addLast-producer添加任务" class="headerlink" title="addLast - producer添加任务"></a>addLast - producer添加任务</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ADD_CLOSED | ADD_FROZEN | ADD_SUCCESS</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addLast</span><span class="params">(element: <span class="type">E</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    _state.loop &#123; state -&gt;</span><br><span class="line">        <span class="comment">// 如果当前状态为Frozen或是closed则返回失败原因</span></span><br><span class="line">        <span class="keyword">if</span> (state and (FROZEN_MASK or CLOSED_MASK) != <span class="number">0L</span>) <span class="keyword">return</span> state.addFailReason() <span class="comment">// cannot add</span></span><br><span class="line">        </span><br><span class="line">        state.withState &#123; head, tail -&gt;</span><br><span class="line">            <span class="keyword">val</span> mask = <span class="keyword">this</span>.mask <span class="comment">// manually move instance field to local for performance</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当queue只剩一个空位的时候，freeze并且扩容，因为single consumer的时候，可能会有一个element我们并不能overwrite</span></span><br><span class="line">            <span class="comment">// 在removeFirst的时候，因为removeFirst是先更新head index，再拿掉当前的element，所以需要进行extra margin of one element检查</span></span><br><span class="line">            <span class="comment">// If queue is Single-Consumer then there could be one element beyond head that we cannot overwrite,</span></span><br><span class="line">            <span class="comment">// so we check for full queue with an extra margin of one element</span></span><br><span class="line">            <span class="keyword">if</span> ((tail + <span class="number">2</span>) and mask == head and mask) <span class="keyword">return</span> ADD_FROZEN <span class="comment">// overfull, so do freeze &amp; copy</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// If queue is Multi-Consumer then the consumer could still have not cleared element</span></span><br><span class="line">            <span class="comment">// despite the above check for one free slot.</span></span><br><span class="line">            <span class="keyword">if</span> (!singleConsumer &amp;&amp; array[tail and mask].value != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是multi consumer，这个时候要两种情况</span></span><br><span class="line">                <span class="comment">// 1. 当queue的capacity &lt; 1024或整个queue已经用掉了一半的时候，进行扩容</span></span><br><span class="line">                <span class="comment">// 2. 否则，spin来等待consumer来拿任务</span></span><br><span class="line">                <span class="comment">// 这个case就是之前singleConsumer注释所说的，这个queue并不是lock free，因为这种情况会spin来等待consumer来take这个任务</span></span><br><span class="line">                <span class="comment">// There are two options in this situation</span></span><br><span class="line">                <span class="comment">// 1. Spin-wait until consumer clears the slot</span></span><br><span class="line">                <span class="comment">// 2. Freeze &amp; resize to avoid spinning</span></span><br><span class="line">                <span class="comment">// We use heuristic here to avoid memory-overallocation</span></span><br><span class="line">                <span class="comment">// Freeze &amp; reallocate when queue is small or more than half of the queue is used</span></span><br><span class="line">                <span class="keyword">if</span> (capacity &lt; MIN_ADD_SPIN_CAPACITY || (tail - head) and MAX_CAPACITY_MASK &gt; capacity shr <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ADD_FROZEN</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// otherwise spin</span></span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@loop</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取新的tail的位置</span></span><br><span class="line">            <span class="keyword">val</span> newTail = (tail + <span class="number">1</span>) and MAX_CAPACITY_MASK</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 原子操作，来确保state成功更新，如果compareAndSet返回false，此时state被别的thread更新，则继续loop</span></span><br><span class="line">            <span class="comment">// 因为这个library是target multi platform，这个地方的compareAndSet不止是Java的compareAndSet，也有JS和native</span></span><br><span class="line">            <span class="keyword">if</span> (_state.compareAndSet(state, state.updateTail(newTail))) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// successfully added</span></span><br><span class="line">                array[tail and mask].value = element</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 因为在set value的时候，有可能别的thread更新了状态，所以需要进行检查</span></span><br><span class="line">                <span class="comment">// could have been frozen &amp; copied before this item was set -- correct it by filling placeholder</span></span><br><span class="line">                <span class="keyword">var</span> cur = <span class="keyword">this</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 没有frozen，那说明addLast成功执行，exit loop</span></span><br><span class="line">                    <span class="keyword">if</span> (cur._state.value and FROZEN_MASK == <span class="number">0L</span>) <span class="keyword">break</span> <span class="comment">// all fine -- not frozen yet</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果当前的queue被frozen了，证明在当前thread set queue的时候，这个queue被扩容了</span></span><br><span class="line">                    <span class="comment">// 之前注释next的时候提到过，queue扩容时会生成一个新的queue object，把当前的queue._next指到queue上</span></span><br><span class="line">                    <span class="comment">// 因为在扩容时，新生成的queue array会判断每个element是否为null，如果不为null则copy，</span></span><br><span class="line">                    <span class="comment">// 如果为null，扩容线程知道有别的thread更新了tail index但还没来得及写入新的element进array里边</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果fillPlaceholder返回null，我们不需要再继续检查了，因为确认写入的element被成功复制到了新的queue里</span></span><br><span class="line">                    <span class="comment">// 如果返回的是新的queue，那么就说明，扩容线程复制的时候并没有复制当前element，fillPlaceholder进行了补写操作</span></span><br><span class="line">                    <span class="comment">// 当前element到扩容的array里边，这个时候，我们需要继续loop，因为可能扩容线程扩容之后，又有别的线程进行了扩容</span></span><br><span class="line">                    <span class="comment">// 这时loop会持续补写直到我们发现不需要array里的值不是Placeholder instance为止</span></span><br><span class="line">                    cur = cur.next().fillPlaceholder(tail, element) ?: <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ADD_SUCCESS <span class="comment">// added successfully</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fillPlaceholder</span><span class="params">(index: <span class="type">Int</span>, element: <span class="type">E</span>)</span></span>: Core&lt;E&gt;? &#123;</span><br><span class="line">    <span class="comment">// 获取这个index里边存的值</span></span><br><span class="line">    <span class="keyword">val</span> old = array[index and mask].value</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * addLast actions: addLast的操作</span></span><br><span class="line"><span class="comment">     * 1) Commit tail slot 更新tail的index，也就是allocate tail的slot</span></span><br><span class="line"><span class="comment">     * 2) Write element to array slot 写入element到array里边</span></span><br><span class="line"><span class="comment">     * 3) Check for array copy 检查array是否扩容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在操作过程中如果第2步和第3步过程中，发生了扩容，consumer有可能已经获取了这个element</span></span><br><span class="line"><span class="comment">     * If copy happened between 2 and 3 then the consumer might have consumed our element,</span></span><br><span class="line"><span class="comment">     * then another producer might have written its placeholder in our slot, so we should</span></span><br><span class="line"><span class="comment">     * perform *unique* check that current placeholder is our to avoid overwriting another producer placeholder</span></span><br><span class="line"><span class="comment">     * 如果Placeholder里边的index是方法传入的index，这时我们确定这个Placeholder是当前线程的Placeholder，而不是其他producer的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (old <span class="keyword">is</span> Placeholder &amp;&amp; old.index == index) &#123;</span><br><span class="line">        <span class="comment">// 因为扩容的时候，扩容线程复制了老的array，此时，当前producer线程并没有写入新的element，这个操作是把element写进扩容后的array</span></span><br><span class="line">        array[index and mask].value = element</span><br><span class="line">        <span class="comment">// we&#x27;ve corrected missing element, should check if that propagated to further copies, just in case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回null，这种情况是扩容线程在扩容的时候，已经看到了producer线程写入的新element</span></span><br><span class="line">    <span class="comment">// 这个时候我们不需要做进行next的check，因为之后即便再有扩容，已经写进当前扩容的element都会被复制到之后的扩容array里</span></span><br><span class="line">    <span class="comment">// it is Ok, no need for further action</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="removeFistOrNull-consumer来拿任务，如果没有任务，则返回null"><a href="#removeFistOrNull-consumer来拿任务，如果没有任务，则返回null" class="headerlink" title="removeFistOrNull consumer来拿任务，如果没有任务，则返回null"></a>removeFistOrNull consumer来拿任务，如果没有任务，则返回null</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// REMOVE_FROZEN | null (EMPTY) | E (SUCCESS)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeFirstOrNull</span><span class="params">()</span></span>: Any? &#123;</span><br><span class="line">    _state.loop &#123; state -&gt;</span><br><span class="line">        <span class="comment">// 当前queue已被frozen，发生了扩容，返回这个状态，让调用这个方法的consumer决定该做什么</span></span><br><span class="line">        <span class="keyword">if</span> (state and FROZEN_MASK != <span class="number">0L</span>) <span class="keyword">return</span> REMOVE_FROZEN <span class="comment">// frozen -- cannot modify</span></span><br><span class="line">        state.withState &#123; head, tail -&gt;</span><br><span class="line">            <span class="comment">// 当前queue为空，返回null</span></span><br><span class="line">            <span class="keyword">if</span> ((tail and mask) == (head and mask)) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// empty</span></span><br><span class="line">            <span class="keyword">val</span> element = array[head and mask].value</span><br><span class="line">            <span class="keyword">if</span> (element == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是single consumer，则producer没有完成加入element</span></span><br><span class="line">                <span class="comment">// If queue is Single-Consumer, then element == null only when add has not finished yet</span></span><br><span class="line">                <span class="keyword">if</span> (singleConsumer) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// consider it not added yet</span></span><br><span class="line">                <span class="comment">// 如果是multi consumer，我们需要spin，来尝试继续获取element，这个是之前说的这个queue会spin</span></span><br><span class="line">                <span class="comment">// retry (spin) until consumer adds it</span></span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@loop</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前element是Placeholder，说明producer还没来得及补写扩容之后的queue array，这时我们认为状态是not added yet，所以返回null</span></span><br><span class="line">            <span class="comment">// element == Placeholder can only be when add has not finished yet</span></span><br><span class="line">            <span class="keyword">if</span> (element <span class="keyword">is</span> Placeholder) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// consider it not added yet</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 我们这个地方不能直接更新element为null，因为会有一个edge case</span></span><br><span class="line">            <span class="comment">// 情况为：当前有两个线程，一个producer线程即将进行扩容，一个consumer线程，</span></span><br><span class="line">            <span class="comment">// 假设consumer线程直接把array[head]变成了null，之后producer线程进行扩容，因为扩容时，null的element会被当做是别的producer线程还没来得及写入的element</span></span><br><span class="line">            <span class="comment">// 这时扩容线程把这个element变成了placeholder，这回break queue的状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正确操作是先更新head index，如果更新成功，再将array[previous head]设成null，因为这个时候即便producer线程进行扩容，也只会copy新的head到tail的elements</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// we cannot put null into array here, because copying thread could replace it with Placeholder and that is a disaster</span></span><br><span class="line">            <span class="keyword">val</span> newHead = (head + <span class="number">1</span>) and MAX_CAPACITY_MASK</span><br><span class="line">            <span class="keyword">if</span> (_state.compareAndSet(state, state.updateHead(newHead))) &#123;</span><br><span class="line">                <span class="comment">// Array could have been copied by another thread and it is perfectly fine, since only elements</span></span><br><span class="line">                <span class="comment">// between head and tail were copied and there are no extra steps we should take here</span></span><br><span class="line">                array[head and mask].value = <span class="literal">null</span> <span class="comment">// now can safely put null (state was updated)</span></span><br><span class="line">                <span class="keyword">return</span> element <span class="comment">// successfully removed in fast-path</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// multi consumer的时候需要spin来确保当前head不被别的consumer拿掉</span></span><br><span class="line">            <span class="comment">// Multi-Consumer queue must retry this loop on CAS failure (another consumer might have removed element)</span></span><br><span class="line">            <span class="keyword">if</span> (!singleConsumer) <span class="keyword">return</span><span class="symbol">@loop</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果是single consumer的case，之前的compareAndSet失败是因为producer线程进行了扩容</span></span><br><span class="line">            <span class="comment">// 这个时候需要从扩容之后的queue里边拿到element，并且更新head</span></span><br><span class="line">            <span class="comment">// Single-consumer queue goes to slow-path for remove in case of interference</span></span><br><span class="line">            <span class="keyword">var</span> cur = <span class="keyword">this</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="meta">@Suppress(<span class="meta-string">&quot;UNUSED_VALUE&quot;</span>)</span></span><br><span class="line">                cur = cur.removeSlowPath(head, newHead) ?: <span class="keyword">return</span> element</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeSlowPath</span><span class="params">(oldHead: <span class="type">Int</span>, newHead: <span class="type">Int</span>)</span></span>: Core&lt;E&gt;? &#123;</span><br><span class="line">    _state.loop &#123; state -&gt;</span><br><span class="line">        state.withState &#123; head, _ -&gt;</span><br><span class="line">            <span class="comment">// Extra检查，head值不应该变，如果变化了，说明并不是single consumer，</span></span><br><span class="line">            <span class="comment">// 这个时候会报错，因为single consumer的操作和multi consumer操作不一样，assumption不正确queue的操作就不正确</span></span><br><span class="line">            assert &#123; head == oldHead &#125; <span class="comment">// &quot;This queue can have only one consumer&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Frozen状态说明扩容了，这个时候要去point到扩容之后的queue</span></span><br><span class="line">            <span class="keyword">if</span> (state and FROZEN_MASK != <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// state was already frozen, so removed element was copied to next</span></span><br><span class="line">                <span class="keyword">return</span> next() <span class="comment">// continue to correct head in next</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原子操作更新head，如果这个时候更新成功，则将head 设成null</span></span><br><span class="line">            <span class="comment">// 更新不成功，说明有别的producer线程又进行了扩容，这个时候需要继续loop，直到head成功被更新，也就是没有别的线程扩容</span></span><br><span class="line">            <span class="keyword">if</span> (_state.compareAndSet(state, state.updateHead(newHead))) &#123;</span><br><span class="line">                array[head and mask].value = <span class="literal">null</span> <span class="comment">// now can safely put null (state was updated)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容逻辑，在addLast的时候，满足之前提到的条件会进行扩容"><a href="#扩容逻辑，在addLast的时候，满足之前提到的条件会进行扩容" class="headerlink" title="扩容逻辑，在addLast的时候，满足之前提到的条件会进行扩容"></a>扩容逻辑，在addLast的时候，满足之前提到的条件会进行扩容</h3><p>扩容实际是copy之前的array里边的元素到新的array里边</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前queue的next或是copy，如果有next则说明别的线程扩容了，如果next是null，则进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: LockFreeTaskQueueCore&lt;E&gt; = allocateOrGetNextCopy(markFrozen())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把当前state标记成frozen，提示其他线程，这个queue已经过期（有新的扩容queue生成）</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">markFrozen</span><span class="params">()</span></span>: <span class="built_in">Long</span> =</span><br><span class="line">    _state.updateAndGet &#123; state -&gt;</span><br><span class="line">        <span class="keyword">if</span> (state and FROZEN_MASK != <span class="number">0L</span>) <span class="keyword">return</span> state <span class="comment">// already marked</span></span><br><span class="line">        state or FROZEN_MASK</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">allocateOrGetNextCopy</span><span class="params">(state: <span class="type">Long</span>)</span></span>: Core&lt;E&gt; &#123;</span><br><span class="line">    _next.loop &#123; next -&gt;</span><br><span class="line">        <span class="comment">// 如果next不为null，期间已有别的线程扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (next != <span class="literal">null</span>) <span class="keyword">return</span> next <span class="comment">// already allocated &amp; copied</span></span><br><span class="line">        <span class="comment">// 如果是null，则进行扩容</span></span><br><span class="line">        <span class="comment">// 因为在扩容时，可能有别的线程更改了状态，所以compareAndSet失败的时候，next依旧为null，这时进行继续loop check</span></span><br><span class="line">        <span class="comment">// 这个地方也是个spin</span></span><br><span class="line">        _next.compareAndSet(<span class="literal">null</span>, allocateNextCopy(state))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">allocateNextCopy</span><span class="params">(state: <span class="type">Long</span>)</span></span>: Core&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 生成一个新的Queue，容量是之前的两倍</span></span><br><span class="line">    <span class="keyword">val</span> next = LockFreeTaskQueueCore&lt;E&gt;(capacity * <span class="number">2</span>, singleConsumer)</span><br><span class="line">    state.withState &#123; head, tail -&gt;</span><br><span class="line">        <span class="keyword">var</span> index = head</span><br><span class="line">        <span class="comment">// 扩容逻辑，range是head index到tail index</span></span><br><span class="line">        <span class="comment">// 之前提到过，removeFirst会先更新head index，addLast会先更新tail index</span></span><br><span class="line">        <span class="keyword">while</span> (index and mask != tail and mask) &#123;</span><br><span class="line">            <span class="comment">// 如果array[index]不为null，则复制到新的array，如果是null，说明此时producer线程更新完tail index后还没写入array</span></span><br><span class="line">            <span class="comment">// 这个时候我们创建一个Placeholder，来给producer线程补写element进扩容后的array</span></span><br><span class="line">            <span class="comment">// replace nulls with placeholders on copy</span></span><br><span class="line">            <span class="keyword">val</span> value = array[index and mask].value ?: Placeholder(index)</span><br><span class="line">            next.array[index and next.mask].value = value</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新状态，reset frozen flag为0</span></span><br><span class="line">        next._state.value = state wo FROZEN_MASK</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后LockFreeTaskQueue，这里边的逻辑比较straight-forward"><a href="#最后LockFreeTaskQueue，这里边的逻辑比较straight-forward" class="headerlink" title="最后LockFreeTaskQueue，这里边的逻辑比较straight forward"></a>最后LockFreeTaskQueue，这里边的逻辑比较straight forward</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeTaskQueue</span>&lt;<span class="type">E : Any</span>&gt;</span>(</span><br><span class="line">    singleConsumer: <span class="built_in">Boolean</span> <span class="comment">// true when there is only a single consumer (slightly faster &amp; lock-free)</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _cur = atomic(Core&lt;E&gt;(Core.INITIAL_CAPACITY, singleConsumer))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: it is not atomic w.r.t. remove operation (remove can transiently fail when isEmpty is false)</span></span><br><span class="line">    <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = _cur.value.isEmpty</span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span> <span class="keyword">get</span>() = _cur.value.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 不断尝试close当前queue，因为可能发生扩容，所以要不断spin来尝试</span></span><br><span class="line">        _cur.loop &#123; cur -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cur.close()) <span class="keyword">return</span> <span class="comment">// closed this copy</span></span><br><span class="line">            _cur.compareAndSet(cur, cur.next()) <span class="comment">// move to next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addLast</span><span class="params">(element: <span class="type">E</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        _cur.loop &#123; cur -&gt;</span><br><span class="line">            <span class="comment">// addLast</span></span><br><span class="line">            <span class="keyword">when</span> (cur.addLast(element)) &#123;</span><br><span class="line">                Core.ADD_SUCCESS -&gt; <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                Core.ADD_CLOSED -&gt; <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                <span class="comment">// Frozen状态说明有扩容，获取扩容后的queue，这个地方进行了spin</span></span><br><span class="line">                Core.ADD_FROZEN -&gt; _cur.compareAndSet(cur, cur.next()) <span class="comment">// move to next</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeFirstOrNull</span><span class="params">()</span></span>: E? &#123;</span><br><span class="line">        _cur.loop &#123; cur -&gt;</span><br><span class="line">            <span class="keyword">val</span> result = cur.removeFirstOrNull()</span><br><span class="line">            <span class="keyword">if</span> (result !== Core.REMOVE_FROZEN) <span class="keyword">return</span> result <span class="keyword">as</span> E?</span><br><span class="line">            <span class="comment">// Frozen状态说明有扩容，获取扩容后的queue，这个地方进行了spin</span></span><br><span class="line">            _cur.compareAndSet(cur, cur.next())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used for validation in tests only</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">map</span><span class="params">(transform: (<span class="type">E</span>) -&gt; <span class="type">R</span>)</span></span>: List&lt;R&gt; = _cur.value.map(transform)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used for validation in tests only</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isClosed</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = _cur.value.isClosed()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本每一个要处理异步编程的library都需要有个queue来维护任务，Kotlin这个coroutine因为要target multiplatform，<br>写这么个queue要考虑很多case，因为有的platform可能是single consumer，有的又是multi consumer，<br>为了这个还写了不同的处理逻辑，也算是做到极致了。</p>
<p>对比别的library可能值需要做到MPSC，比如Reactor的 <a target="_blank" rel="noopener" href="https://github.com/reactor/reactor-core/blob/933fc90572194db080590e3b2f96b91147aebb4a/reactor-core/src/main/java/reactor/util/concurrent/MpscLinkedQueue.java">MpscLinkedQueue</a><br>，kotlin coroutine的queue的逻辑要复杂得多。</p>
<p>在效率方面，如果是对于target是JVM的，应该跟用线程池实现NIO的效率差不多，我记得之前看扔物线的 <a target="_blank" rel="noopener" href="https://youtu.be/LKsGkEsEE7w">Kotlin的协程</a><br>提到过这个概念，Kotlin的coroutine并不会比线程池更效率，因为它底层也是这么实现的。</p>
<p>而且从另一个角度看，在JS里，这种在Kotlin维护一个task queue，未必比native的event loop更效率，<br>因为Kotlin最终是transpile成了JS，而Node里边的event loop是libuv用C实现的。</p>
<p>不知道这个想法对不对。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.yuanchenxi95.com/2021/11/09/Kotlin-Coroutine-LockFreeTaskQueue-%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A/" data-id="cm8ffnq2z0004khnhhelvdtpg" data-title="Kotlin Coroutine LockFreeTaskQueue 源码注释" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/01/31/HTTP%E6%96%B0method-Query/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          HTTP新method: Query
        
      </div>
    </a>
  
  
    <a href="/2021/06/27/%E8%A7%86%E9%A2%91%E7%B1%BB%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E9%AA%8C%E6%80%BB%E7%BB%93/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">视频类应用的体验总结</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Earnings/" rel="tag">Earnings</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netflix/" rel="tag">Netflix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reviews/" rel="tag">Reviews</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Summary/" rel="tag">Summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thoughts/" rel="tag">Thoughts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Video-Apps/" rel="tag">Video Apps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xiaomi/" rel="tag">Xiaomi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xiacy/" rel="tag">xiacy</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Earnings/" style="font-size: 20px;">Earnings</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Netflix/" style="font-size: 10px;">Netflix</a> <a href="/tags/Reviews/" style="font-size: 10px;">Reviews</a> <a href="/tags/Summary/" style="font-size: 10px;">Summary</a> <a href="/tags/Thoughts/" style="font-size: 10px;">Thoughts</a> <a href="/tags/Video-Apps/" style="font-size: 10px;">Video Apps</a> <a href="/tags/Xiaomi/" style="font-size: 10px;">Xiaomi</a> <a href="/tags/xiacy/" style="font-size: 10px;">xiacy</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/18/%E5%B0%8F%E7%B1%B3%E9%9B%86%E5%9B%A22024%E5%B9%B4%E6%8A%A5/">小米集团2024年报</a>
          </li>
        
          <li>
            <a href="/2025/02/13/tech-blog-index/">tech-blog-index</a>
          </li>
        
          <li>
            <a href="/2024/07/19/Netflix%E8%B4%A2%E6%8A%A52024Q2%E6%80%BB%E7%BB%93/">Netflix财报2024Q2总结</a>
          </li>
        
          <li>
            <a href="/2022/01/31/HTTP%E6%96%B0method-Query/">HTTP新method: Query</a>
          </li>
        
          <li>
            <a href="/2021/11/09/Kotlin-Coroutine-LockFreeTaskQueue-%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A/">Kotlin Coroutine LockFreeTaskQueue 源码注释</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Chenxi Yuan<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>